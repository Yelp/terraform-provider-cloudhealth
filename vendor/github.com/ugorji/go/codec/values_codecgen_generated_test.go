// +build codecgen generated

// Code generated by codecgen - DO NOT EDIT.

package codec

import (
	"errors"
	"runtime"
	"strconv"
	"time"
)

const (
	// ----- content types ----
	codecSelferCcUTF819780 = 1
	codecSelferCcRAW19780  = 255
	// ----- value types used ----
	codecSelferValueTypeArray19780  = 10
	codecSelferValueTypeMap19780    = 9
	codecSelferValueTypeString19780 = 6
	codecSelferValueTypeInt19780    = 2
	codecSelferValueTypeUint19780   = 3
	codecSelferValueTypeFloat19780  = 4
	codecSelferBitsize19780         = uint8(32 << (^uint(0) >> 63))
)

var (
	errCodecSelferOnlyMapOrArrayEncodeToStruct19780 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer19780 struct{}

func codecSelfer19780False() bool { return false }

func init() {
	if GenVersion != 13 {
		_, file, _, _ := runtime.Caller(0)
		ver := strconv.FormatInt(int64(GenVersion), 10)
		panic("codecgen version mismatch: current: 13, need " + ver + ". Re-generate file: " + file)
	}
	if false { // reference the types, but skip this branch at build/run time
		var _ byte
		var _ time.Time
	}
}

func (x wrapSliceUint64) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encwrapSliceUint64((wrapSliceUint64)(x), e)
	}
}

func (x *wrapSliceUint64) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decwrapSliceUint64((*wrapSliceUint64)(x), d)
}

func (x wrapSliceString) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encwrapSliceString((wrapSliceString)(x), e)
	}
}

func (x *wrapSliceString) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decwrapSliceString((*wrapSliceString)(x), d)
}

func (x wrapUint64) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.EncodeUint(uint64(x))
}

func (x *wrapUint64) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	*x = (wrapUint64)(r.DecodeUint64())
}

func (x wrapString) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if z.EncBasicHandle().StringToRaw {
		r.EncodeStringBytesRaw(z.BytesView(string(x)))
	} else {
		r.EncodeStringEnc(codecSelferCcUTF819780, string(x))
	}
}

func (x *wrapString) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	*x = (wrapString)(string(r.DecodeStringAsBytes()))
}

func (x wrapUint64Slice) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encwrapUint64Slice((wrapUint64Slice)(x), e)
	}
}

func (x *wrapUint64Slice) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decwrapUint64Slice((*wrapUint64Slice)(x), d)
}

func (x wrapStringSlice) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encwrapStringSlice((wrapStringSlice)(x), e)
	}
}

func (x *wrapStringSlice) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decwrapStringSlice((*wrapStringSlice)(x), d)
}

func (x *stringUint64T) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.U))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"U\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `U`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.U))
			z.EncWriteMapEnd()
		}
	}
}

func (x *stringUint64T) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *stringUint64T) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "S":
			if r.TryDecodeAsNil() {
				x.S = ""
			} else {
				x.S = (string)(string(r.DecodeStringAsBytes()))
			}
		case "U":
			if r.TryDecodeAsNil() {
				x.U = 0
			} else {
				x.U = (uint64)(r.DecodeUint64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *stringUint64T) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.S = ""
	} else {
		x.S = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.U = 0
	} else {
		x.U = (uint64)(r.DecodeUint64())
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *AnonInTestStruc) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(15)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.AS)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.AS))
			}
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.AI64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.AI16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.AUi64))
			z.EncWriteArrayElem()
			z.F.EncSliceStringV(x.ASslice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt64V(x.AI64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceUint64V(x.AUi64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceFloat64V(x.AF64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceFloat32V(x.AF32slice, e)
			z.EncWriteArrayElem()
			h.encMapstringuint16((map[string]uint16)(x.AMSU16), e)
			z.EncWriteArrayElem()
			yy28 := &x.AI64arr0
			h.encArray0int64((*[0]int64)(yy28), e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt64V(x.AI64slice0, e)
			z.EncWriteArrayElem()
			z.F.EncSliceUint64V(x.AUi64sliceN, e)
			z.EncWriteArrayElem()
			h.encMapstringuint16((map[string]uint16)(x.AMSU16N), e)
			z.EncWriteArrayElem()
			h.encMapstringuint16((map[string]uint16)(x.AMSU16E), e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(15)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AS\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AS`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.AS)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.AS))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.AI64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.AI16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.AUi64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"ASslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `ASslice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceStringV(x.ASslice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt64V(x.AI64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceUint64V(x.AUi64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AF64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AF64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceFloat64V(x.AF64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AF32slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AF32slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceFloat32V(x.AF32slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AMSU16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringuint16((map[string]uint16)(x.AMSU16), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64arr0\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64arr0`)
			}
			z.EncWriteMapElemValue()
			yy44 := &x.AI64arr0
			h.encArray0int64((*[0]int64)(yy44), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice0\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64slice0`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt64V(x.AI64slice0, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64sliceN\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64sliceN`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceUint64V(x.AUi64sliceN, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AMSU16N\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16N`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringuint16((map[string]uint16)(x.AMSU16N), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AMSU16E\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16E`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringuint16((map[string]uint16)(x.AMSU16E), e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *AnonInTestStruc) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *AnonInTestStruc) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "AS":
			if r.TryDecodeAsNil() {
				x.AS = ""
			} else {
				x.AS = (string)(string(r.DecodeStringAsBytes()))
			}
		case "AI64":
			if r.TryDecodeAsNil() {
				x.AI64 = 0
			} else {
				x.AI64 = (int64)(r.DecodeInt64())
			}
		case "AI16":
			if r.TryDecodeAsNil() {
				x.AI16 = 0
			} else {
				x.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "AUi64":
			if r.TryDecodeAsNil() {
				x.AUi64 = 0
			} else {
				x.AUi64 = (uint64)(r.DecodeUint64())
			}
		case "ASslice":
			if r.TryDecodeAsNil() {
				x.ASslice = nil
			} else {
				z.F.DecSliceStringX(&x.ASslice, d)
			}
		case "AI64slice":
			if r.TryDecodeAsNil() {
				x.AI64slice = nil
			} else {
				z.F.DecSliceInt64X(&x.AI64slice, d)
			}
		case "AUi64slice":
			if r.TryDecodeAsNil() {
				x.AUi64slice = nil
			} else {
				z.F.DecSliceUint64X(&x.AUi64slice, d)
			}
		case "AF64slice":
			if r.TryDecodeAsNil() {
				x.AF64slice = nil
			} else {
				z.F.DecSliceFloat64X(&x.AF64slice, d)
			}
		case "AF32slice":
			if r.TryDecodeAsNil() {
				x.AF32slice = nil
			} else {
				z.F.DecSliceFloat32X(&x.AF32slice, d)
			}
		case "AMSU16":
			if r.TryDecodeAsNil() {
				x.AMSU16 = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.AMSU16), d)
			}
		case "AI64arr0":
			if r.TryDecodeAsNil() {
				x.AI64arr0 = [0]int64{}
			} else {
				h.decArray0int64((*[0]int64)(&x.AI64arr0), d)
			}
		case "AI64slice0":
			if r.TryDecodeAsNil() {
				x.AI64slice0 = nil
			} else {
				z.F.DecSliceInt64X(&x.AI64slice0, d)
			}
		case "AUi64sliceN":
			if r.TryDecodeAsNil() {
				x.AUi64sliceN = nil
			} else {
				z.F.DecSliceUint64X(&x.AUi64sliceN, d)
			}
		case "AMSU16N":
			if r.TryDecodeAsNil() {
				x.AMSU16N = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.AMSU16N), d)
			}
		case "AMSU16E":
			if r.TryDecodeAsNil() {
				x.AMSU16E = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.AMSU16E), d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *AnonInTestStruc) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj30 int
	var yyb30 bool
	var yyhl30 bool = l >= 0
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AS = ""
	} else {
		x.AS = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AI64 = 0
	} else {
		x.AI64 = (int64)(r.DecodeInt64())
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AI16 = 0
	} else {
		x.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AUi64 = 0
	} else {
		x.AUi64 = (uint64)(r.DecodeUint64())
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ASslice = nil
	} else {
		z.F.DecSliceStringX(&x.ASslice, d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AI64slice = nil
	} else {
		z.F.DecSliceInt64X(&x.AI64slice, d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AUi64slice = nil
	} else {
		z.F.DecSliceUint64X(&x.AUi64slice, d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AF64slice = nil
	} else {
		z.F.DecSliceFloat64X(&x.AF64slice, d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AF32slice = nil
	} else {
		z.F.DecSliceFloat32X(&x.AF32slice, d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AMSU16 = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.AMSU16), d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AI64arr0 = [0]int64{}
	} else {
		h.decArray0int64((*[0]int64)(&x.AI64arr0), d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AI64slice0 = nil
	} else {
		z.F.DecSliceInt64X(&x.AI64slice0, d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AUi64sliceN = nil
	} else {
		z.F.DecSliceUint64X(&x.AUi64sliceN, d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AMSU16N = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.AMSU16N), d)
	}
	yyj30++
	if yyhl30 {
		yyb30 = yyj30 > l
	} else {
		yyb30 = r.CheckBreak()
	}
	if yyb30 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AMSU16E = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.AMSU16E), d)
	}
	for {
		yyj30++
		if yyhl30 {
			yyb30 = yyj30 > l
		} else {
			yyb30 = r.CheckBreak()
		}
		if yyb30 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj30-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *testSimpleFields) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(17)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I8))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui64))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui8))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.F64))
			z.EncWriteArrayElem()
			r.EncodeFloat32(float32(x.F32))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.B))
			z.EncWriteArrayElem()
			z.F.EncSliceStringV(x.Sslice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt16V(x.I16slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceUint64V(x.Ui64slice, e)
			z.EncWriteArrayElem()
			r.EncodeStringBytesRaw([]byte(x.Ui8slice))
			z.EncWriteArrayElem()
			z.F.EncSliceBoolV(x.Bslice, e)
			z.EncWriteArrayElem()
			h.encSlicePtrtoint64(([]*int64)(x.Iptrslice), e)
			z.EncWriteArrayElem()
			x.WrapSliceInt64.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.WrapSliceString.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			z.F.EncMapStringInt64V(x.Msi64, e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(17)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui8\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"F64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `F64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.F64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"F32\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `F32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat32(float32(x.F32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.B))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Sslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Sslice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceStringV(x.Sslice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I16slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt16V(x.I16slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceUint64V(x.Ui64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui8slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui8slice`)
			}
			z.EncWriteMapElemValue()
			r.EncodeStringBytesRaw([]byte(x.Ui8slice))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Bslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Bslice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceBoolV(x.Bslice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Iptrslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Iptrslice`)
			}
			z.EncWriteMapElemValue()
			h.encSlicePtrtoint64(([]*int64)(x.Iptrslice), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WrapSliceInt64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `WrapSliceInt64`)
			}
			z.EncWriteMapElemValue()
			x.WrapSliceInt64.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WrapSliceString\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `WrapSliceString`)
			}
			z.EncWriteMapElemValue()
			x.WrapSliceString.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Msi64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Msi64`)
			}
			z.EncWriteMapElemValue()
			z.F.EncMapStringInt64V(x.Msi64, e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *testSimpleFields) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *testSimpleFields) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "S":
			if r.TryDecodeAsNil() {
				x.S = ""
			} else {
				x.S = (string)(string(r.DecodeStringAsBytes()))
			}
		case "I64":
			if r.TryDecodeAsNil() {
				x.I64 = 0
			} else {
				x.I64 = (int64)(r.DecodeInt64())
			}
		case "I8":
			if r.TryDecodeAsNil() {
				x.I8 = 0
			} else {
				x.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
			}
		case "Ui64":
			if r.TryDecodeAsNil() {
				x.Ui64 = 0
			} else {
				x.Ui64 = (uint64)(r.DecodeUint64())
			}
		case "Ui8":
			if r.TryDecodeAsNil() {
				x.Ui8 = 0
			} else {
				x.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		case "F64":
			if r.TryDecodeAsNil() {
				x.F64 = 0
			} else {
				x.F64 = (float64)(r.DecodeFloat64())
			}
		case "F32":
			if r.TryDecodeAsNil() {
				x.F32 = 0
			} else {
				x.F32 = (float32)(z.DecDecodeFloat32())
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.B = false
			} else {
				x.B = (bool)(r.DecodeBool())
			}
		case "Sslice":
			if r.TryDecodeAsNil() {
				x.Sslice = nil
			} else {
				z.F.DecSliceStringX(&x.Sslice, d)
			}
		case "I16slice":
			if r.TryDecodeAsNil() {
				x.I16slice = nil
			} else {
				z.F.DecSliceInt16X(&x.I16slice, d)
			}
		case "Ui64slice":
			if r.TryDecodeAsNil() {
				x.Ui64slice = nil
			} else {
				z.F.DecSliceUint64X(&x.Ui64slice, d)
			}
		case "Ui8slice":
			if r.TryDecodeAsNil() {
				x.Ui8slice = nil
			} else {
				x.Ui8slice = r.DecodeBytes(([]byte)(x.Ui8slice), false)
			}
		case "Bslice":
			if r.TryDecodeAsNil() {
				x.Bslice = nil
			} else {
				z.F.DecSliceBoolX(&x.Bslice, d)
			}
		case "Iptrslice":
			if r.TryDecodeAsNil() {
				x.Iptrslice = nil
			} else {
				h.decSlicePtrtoint64((*[]*int64)(&x.Iptrslice), d)
			}
		case "WrapSliceInt64":
			if r.TryDecodeAsNil() {
				x.WrapSliceInt64 = nil
			} else {
				x.WrapSliceInt64.CodecDecodeSelf(d)
			}
		case "WrapSliceString":
			if r.TryDecodeAsNil() {
				x.WrapSliceString = nil
			} else {
				x.WrapSliceString.CodecDecodeSelf(d)
			}
		case "Msi64":
			if r.TryDecodeAsNil() {
				x.Msi64 = nil
			} else {
				z.F.DecMapStringInt64X(&x.Msi64, d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *testSimpleFields) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj28 int
	var yyb28 bool
	var yyhl28 bool = l >= 0
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.S = ""
	} else {
		x.S = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I64 = 0
	} else {
		x.I64 = (int64)(r.DecodeInt64())
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I8 = 0
	} else {
		x.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui64 = 0
	} else {
		x.Ui64 = (uint64)(r.DecodeUint64())
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui8 = 0
	} else {
		x.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.F64 = 0
	} else {
		x.F64 = (float64)(r.DecodeFloat64())
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.F32 = 0
	} else {
		x.F32 = (float32)(z.DecDecodeFloat32())
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.B = false
	} else {
		x.B = (bool)(r.DecodeBool())
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Sslice = nil
	} else {
		z.F.DecSliceStringX(&x.Sslice, d)
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I16slice = nil
	} else {
		z.F.DecSliceInt16X(&x.I16slice, d)
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui64slice = nil
	} else {
		z.F.DecSliceUint64X(&x.Ui64slice, d)
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui8slice = nil
	} else {
		x.Ui8slice = r.DecodeBytes(([]byte)(x.Ui8slice), false)
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Bslice = nil
	} else {
		z.F.DecSliceBoolX(&x.Bslice, d)
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Iptrslice = nil
	} else {
		h.decSlicePtrtoint64((*[]*int64)(&x.Iptrslice), d)
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WrapSliceInt64 = nil
	} else {
		x.WrapSliceInt64.CodecDecodeSelf(d)
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WrapSliceString = nil
	} else {
		x.WrapSliceString.CodecDecodeSelf(d)
	}
	yyj28++
	if yyhl28 {
		yyb28 = yyj28 > l
	} else {
		yyb28 = r.CheckBreak()
	}
	if yyb28 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Msi64 = nil
	} else {
		z.F.DecMapStringInt64X(&x.Msi64, d)
	}
	for {
		yyj28++
		if yyhl28 {
			yyb28 = yyj28 > l
		} else {
			yyb28 = r.CheckBreak()
		}
		if yyb28 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj28-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *TestStrucCommon) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn54 bool = x.Nint64 == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(52)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I32))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I16))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I8))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I64n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I32n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I16n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I8n))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui64))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui32))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui8))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.F64))
			z.EncWriteArrayElem()
			r.EncodeFloat32(float32(x.F32))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.B))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.By))
			z.EncWriteArrayElem()
			z.F.EncSliceStringV(x.Sslice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt64V(x.I64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt16V(x.I16slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceUint64V(x.Ui64slice, e)
			z.EncWriteArrayElem()
			r.EncodeStringBytesRaw([]byte(x.Ui8slice))
			z.EncWriteArrayElem()
			z.F.EncSliceBoolV(x.Bslice, e)
			z.EncWriteArrayElem()
			r.EncodeStringBytesRaw([]byte(x.Byslice))
			z.EncWriteArrayElem()
			z.F.EncSliceBytesV(x.BytesSlice, e)
			z.EncWriteArrayElem()
			h.encSlicePtrtoint64(([]*int64)(x.Iptrslice), e)
			z.EncWriteArrayElem()
			x.WrapSliceInt64.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.WrapSliceString.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			z.F.EncMapStringInt64V(x.Msi64, e)
			z.EncWriteArrayElem()
			z.F.EncMapStringBytesV(x.Msbytes, e)
			z.EncWriteArrayElem()
			yy85 := &x.Simplef
			yy85.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			h.encSlicestringUint64T(([]stringUint64T)(x.SstrUi64T), e)
			z.EncWriteArrayElem()
			h.encMapstringPtrtostringUint64T((map[string]*stringUint64T)(x.MstrUi64T), e)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.AnonInTestStruc.AS)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.AnonInTestStruc.AS))
			}
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.AnonInTestStruc.AI64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.AnonInTestStruc.AI16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.AnonInTestStruc.AUi64))
			z.EncWriteArrayElem()
			z.F.EncSliceStringV(x.AnonInTestStruc.ASslice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt64V(x.AnonInTestStruc.AI64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceUint64V(x.AnonInTestStruc.AUi64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceFloat64V(x.AnonInTestStruc.AF64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceFloat32V(x.AnonInTestStruc.AF32slice, e)
			z.EncWriteArrayElem()
			h.encMapstringuint16((map[string]uint16)(x.AnonInTestStruc.AMSU16), e)
			z.EncWriteArrayElem()
			yy99 := &x.AnonInTestStruc.AI64arr0
			h.encArray0int64((*[0]int64)(yy99), e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt64V(x.AnonInTestStruc.AI64slice0, e)
			z.EncWriteArrayElem()
			z.F.EncSliceUint64V(x.AnonInTestStruc.AUi64sliceN, e)
			z.EncWriteArrayElem()
			h.encMapstringuint16((map[string]uint16)(x.AnonInTestStruc.AMSU16N), e)
			z.EncWriteArrayElem()
			h.encMapstringuint16((map[string]uint16)(x.AnonInTestStruc.AMSU16E), e)
			z.EncWriteArrayElem()
			yy105 := &x.NotAnon
			yy105.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			z.F.EncMapStringBoolV(x.Nmap, e)
			z.EncWriteArrayElem()
			r.EncodeStringBytesRaw([]byte(x.Nslice))
			if yyn54 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				yy109 := *x.Nint64
				r.EncodeInt(int64(yy109))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(52)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64n\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I64n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I64n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32n\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I32n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I32n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16n\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I16n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I16n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8n\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I8n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I8n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui32\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui8\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"F64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `F64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.F64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"F32\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `F32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat32(float32(x.F32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.B))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"By\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `By`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.By))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Sslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Sslice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceStringV(x.Sslice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt64V(x.I64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I16slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt16V(x.I16slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceUint64V(x.Ui64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui8slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui8slice`)
			}
			z.EncWriteMapElemValue()
			r.EncodeStringBytesRaw([]byte(x.Ui8slice))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Bslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Bslice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceBoolV(x.Bslice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Byslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Byslice`)
			}
			z.EncWriteMapElemValue()
			r.EncodeStringBytesRaw([]byte(x.Byslice))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"BytesSlice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `BytesSlice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceBytesV(x.BytesSlice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Iptrslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Iptrslice`)
			}
			z.EncWriteMapElemValue()
			h.encSlicePtrtoint64(([]*int64)(x.Iptrslice), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WrapSliceInt64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `WrapSliceInt64`)
			}
			z.EncWriteMapElemValue()
			x.WrapSliceInt64.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WrapSliceString\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `WrapSliceString`)
			}
			z.EncWriteMapElemValue()
			x.WrapSliceString.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Msi64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Msi64`)
			}
			z.EncWriteMapElemValue()
			z.F.EncMapStringInt64V(x.Msi64, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Msbytes\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Msbytes`)
			}
			z.EncWriteMapElemValue()
			z.F.EncMapStringBytesV(x.Msbytes, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Simplef\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Simplef`)
			}
			z.EncWriteMapElemValue()
			yy141 := &x.Simplef
			yy141.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"SstrUi64T\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `SstrUi64T`)
			}
			z.EncWriteMapElemValue()
			h.encSlicestringUint64T(([]stringUint64T)(x.SstrUi64T), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"MstrUi64T\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `MstrUi64T`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringPtrtostringUint64T((map[string]*stringUint64T)(x.MstrUi64T), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AS\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AS`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.AnonInTestStruc.AS)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.AnonInTestStruc.AS))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.AnonInTestStruc.AI64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.AnonInTestStruc.AI16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.AnonInTestStruc.AUi64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"ASslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `ASslice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceStringV(x.AnonInTestStruc.ASslice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt64V(x.AnonInTestStruc.AI64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceUint64V(x.AnonInTestStruc.AUi64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AF64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AF64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceFloat64V(x.AnonInTestStruc.AF64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AF32slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AF32slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceFloat32V(x.AnonInTestStruc.AF32slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AMSU16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringuint16((map[string]uint16)(x.AnonInTestStruc.AMSU16), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64arr0\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64arr0`)
			}
			z.EncWriteMapElemValue()
			yy155 := &x.AnonInTestStruc.AI64arr0
			h.encArray0int64((*[0]int64)(yy155), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice0\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64slice0`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt64V(x.AnonInTestStruc.AI64slice0, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64sliceN\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64sliceN`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceUint64V(x.AnonInTestStruc.AUi64sliceN, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AMSU16N\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16N`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringuint16((map[string]uint16)(x.AnonInTestStruc.AMSU16N), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AMSU16E\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16E`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringuint16((map[string]uint16)(x.AnonInTestStruc.AMSU16E), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"NotAnon\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `NotAnon`)
			}
			z.EncWriteMapElemValue()
			yy161 := &x.NotAnon
			yy161.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nmap\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Nmap`)
			}
			z.EncWriteMapElemValue()
			z.F.EncMapStringBoolV(x.Nmap, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Nslice`)
			}
			z.EncWriteMapElemValue()
			r.EncodeStringBytesRaw([]byte(x.Nslice))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nint64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Nint64`)
			}
			z.EncWriteMapElemValue()
			if yyn54 {
				r.EncodeNil()
			} else {
				yy165 := *x.Nint64
				r.EncodeInt(int64(yy165))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestStrucCommon) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *TestStrucCommon) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "S":
			if r.TryDecodeAsNil() {
				x.S = ""
			} else {
				x.S = (string)(string(r.DecodeStringAsBytes()))
			}
		case "I64":
			if r.TryDecodeAsNil() {
				x.I64 = 0
			} else {
				x.I64 = (int64)(r.DecodeInt64())
			}
		case "I32":
			if r.TryDecodeAsNil() {
				x.I32 = 0
			} else {
				x.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
			}
		case "I16":
			if r.TryDecodeAsNil() {
				x.I16 = 0
			} else {
				x.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "I8":
			if r.TryDecodeAsNil() {
				x.I8 = 0
			} else {
				x.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
			}
		case "I64n":
			if r.TryDecodeAsNil() {
				x.I64n = 0
			} else {
				x.I64n = (int64)(r.DecodeInt64())
			}
		case "I32n":
			if r.TryDecodeAsNil() {
				x.I32n = 0
			} else {
				x.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
			}
		case "I16n":
			if r.TryDecodeAsNil() {
				x.I16n = 0
			} else {
				x.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "I8n":
			if r.TryDecodeAsNil() {
				x.I8n = 0
			} else {
				x.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
			}
		case "Ui64":
			if r.TryDecodeAsNil() {
				x.Ui64 = 0
			} else {
				x.Ui64 = (uint64)(r.DecodeUint64())
			}
		case "Ui32":
			if r.TryDecodeAsNil() {
				x.Ui32 = 0
			} else {
				x.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
			}
		case "Ui16":
			if r.TryDecodeAsNil() {
				x.Ui16 = 0
			} else {
				x.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
			}
		case "Ui8":
			if r.TryDecodeAsNil() {
				x.Ui8 = 0
			} else {
				x.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		case "F64":
			if r.TryDecodeAsNil() {
				x.F64 = 0
			} else {
				x.F64 = (float64)(r.DecodeFloat64())
			}
		case "F32":
			if r.TryDecodeAsNil() {
				x.F32 = 0
			} else {
				x.F32 = (float32)(z.DecDecodeFloat32())
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.B = false
			} else {
				x.B = (bool)(r.DecodeBool())
			}
		case "By":
			if r.TryDecodeAsNil() {
				x.By = 0
			} else {
				x.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		case "Sslice":
			if r.TryDecodeAsNil() {
				x.Sslice = nil
			} else {
				z.F.DecSliceStringX(&x.Sslice, d)
			}
		case "I64slice":
			if r.TryDecodeAsNil() {
				x.I64slice = nil
			} else {
				z.F.DecSliceInt64X(&x.I64slice, d)
			}
		case "I16slice":
			if r.TryDecodeAsNil() {
				x.I16slice = nil
			} else {
				z.F.DecSliceInt16X(&x.I16slice, d)
			}
		case "Ui64slice":
			if r.TryDecodeAsNil() {
				x.Ui64slice = nil
			} else {
				z.F.DecSliceUint64X(&x.Ui64slice, d)
			}
		case "Ui8slice":
			if r.TryDecodeAsNil() {
				x.Ui8slice = nil
			} else {
				x.Ui8slice = r.DecodeBytes(([]byte)(x.Ui8slice), false)
			}
		case "Bslice":
			if r.TryDecodeAsNil() {
				x.Bslice = nil
			} else {
				z.F.DecSliceBoolX(&x.Bslice, d)
			}
		case "Byslice":
			if r.TryDecodeAsNil() {
				x.Byslice = nil
			} else {
				x.Byslice = r.DecodeBytes(([]byte)(x.Byslice), false)
			}
		case "BytesSlice":
			if r.TryDecodeAsNil() {
				x.BytesSlice = nil
			} else {
				z.F.DecSliceBytesX(&x.BytesSlice, d)
			}
		case "Iptrslice":
			if r.TryDecodeAsNil() {
				x.Iptrslice = nil
			} else {
				h.decSlicePtrtoint64((*[]*int64)(&x.Iptrslice), d)
			}
		case "WrapSliceInt64":
			if r.TryDecodeAsNil() {
				x.WrapSliceInt64 = nil
			} else {
				x.WrapSliceInt64.CodecDecodeSelf(d)
			}
		case "WrapSliceString":
			if r.TryDecodeAsNil() {
				x.WrapSliceString = nil
			} else {
				x.WrapSliceString.CodecDecodeSelf(d)
			}
		case "Msi64":
			if r.TryDecodeAsNil() {
				x.Msi64 = nil
			} else {
				z.F.DecMapStringInt64X(&x.Msi64, d)
			}
		case "Msbytes":
			if r.TryDecodeAsNil() {
				x.Msbytes = nil
			} else {
				z.F.DecMapStringBytesX(&x.Msbytes, d)
			}
		case "Simplef":
			if r.TryDecodeAsNil() {
				x.Simplef = testSimpleFields{}
			} else {
				x.Simplef.CodecDecodeSelf(d)
			}
		case "SstrUi64T":
			if r.TryDecodeAsNil() {
				x.SstrUi64T = nil
			} else {
				h.decSlicestringUint64T((*[]stringUint64T)(&x.SstrUi64T), d)
			}
		case "MstrUi64T":
			if r.TryDecodeAsNil() {
				x.MstrUi64T = nil
			} else {
				h.decMapstringPtrtostringUint64T((*map[string]*stringUint64T)(&x.MstrUi64T), d)
			}
		case "AS":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AS = ""
			} else {
				x.AnonInTestStruc.AS = (string)(string(r.DecodeStringAsBytes()))
			}
		case "AI64":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AI64 = 0
			} else {
				x.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
			}
		case "AI16":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AI16 = 0
			} else {
				x.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "AUi64":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AUi64 = 0
			} else {
				x.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
			}
		case "ASslice":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.ASslice = nil
			} else {
				z.F.DecSliceStringX(&x.AnonInTestStruc.ASslice, d)
			}
		case "AI64slice":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AI64slice = nil
			} else {
				z.F.DecSliceInt64X(&x.AnonInTestStruc.AI64slice, d)
			}
		case "AUi64slice":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AUi64slice = nil
			} else {
				z.F.DecSliceUint64X(&x.AnonInTestStruc.AUi64slice, d)
			}
		case "AF64slice":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AF64slice = nil
			} else {
				z.F.DecSliceFloat64X(&x.AnonInTestStruc.AF64slice, d)
			}
		case "AF32slice":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AF32slice = nil
			} else {
				z.F.DecSliceFloat32X(&x.AnonInTestStruc.AF32slice, d)
			}
		case "AMSU16":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AMSU16 = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.AnonInTestStruc.AMSU16), d)
			}
		case "AI64arr0":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AI64arr0 = [0]int64{}
			} else {
				h.decArray0int64((*[0]int64)(&x.AnonInTestStruc.AI64arr0), d)
			}
		case "AI64slice0":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AI64slice0 = nil
			} else {
				z.F.DecSliceInt64X(&x.AnonInTestStruc.AI64slice0, d)
			}
		case "AUi64sliceN":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AUi64sliceN = nil
			} else {
				z.F.DecSliceUint64X(&x.AnonInTestStruc.AUi64sliceN, d)
			}
		case "AMSU16N":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AMSU16N = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.AnonInTestStruc.AMSU16N), d)
			}
		case "AMSU16E":
			if r.TryDecodeAsNil() {
				x.AnonInTestStruc.AMSU16E = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.AnonInTestStruc.AMSU16E), d)
			}
		case "NotAnon":
			if r.TryDecodeAsNil() {
				x.NotAnon = AnonInTestStruc{}
			} else {
				x.NotAnon.CodecDecodeSelf(d)
			}
		case "Nmap":
			if r.TryDecodeAsNil() {
				x.Nmap = nil
			} else {
				z.F.DecMapStringBoolX(&x.Nmap, d)
			}
		case "Nslice":
			if r.TryDecodeAsNil() {
				x.Nslice = nil
			} else {
				x.Nslice = r.DecodeBytes(([]byte)(x.Nslice), false)
			}
		case "Nint64":
			if r.TryDecodeAsNil() {
				if x.Nint64 != nil { // remove the if-true
					x.Nint64 = nil
				}
			} else {
				if x.Nint64 == nil {
					x.Nint64 = new(int64)
				}

				*x.Nint64 = (int64)(r.DecodeInt64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *TestStrucCommon) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj83 int
	var yyb83 bool
	var yyhl83 bool = l >= 0
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.S = ""
	} else {
		x.S = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I64 = 0
	} else {
		x.I64 = (int64)(r.DecodeInt64())
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I32 = 0
	} else {
		x.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I16 = 0
	} else {
		x.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I8 = 0
	} else {
		x.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I64n = 0
	} else {
		x.I64n = (int64)(r.DecodeInt64())
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I32n = 0
	} else {
		x.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I16n = 0
	} else {
		x.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I8n = 0
	} else {
		x.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui64 = 0
	} else {
		x.Ui64 = (uint64)(r.DecodeUint64())
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui32 = 0
	} else {
		x.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui16 = 0
	} else {
		x.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui8 = 0
	} else {
		x.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.F64 = 0
	} else {
		x.F64 = (float64)(r.DecodeFloat64())
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.F32 = 0
	} else {
		x.F32 = (float32)(z.DecDecodeFloat32())
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.B = false
	} else {
		x.B = (bool)(r.DecodeBool())
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.By = 0
	} else {
		x.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Sslice = nil
	} else {
		z.F.DecSliceStringX(&x.Sslice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I64slice = nil
	} else {
		z.F.DecSliceInt64X(&x.I64slice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I16slice = nil
	} else {
		z.F.DecSliceInt16X(&x.I16slice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui64slice = nil
	} else {
		z.F.DecSliceUint64X(&x.Ui64slice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui8slice = nil
	} else {
		x.Ui8slice = r.DecodeBytes(([]byte)(x.Ui8slice), false)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Bslice = nil
	} else {
		z.F.DecSliceBoolX(&x.Bslice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Byslice = nil
	} else {
		x.Byslice = r.DecodeBytes(([]byte)(x.Byslice), false)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BytesSlice = nil
	} else {
		z.F.DecSliceBytesX(&x.BytesSlice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Iptrslice = nil
	} else {
		h.decSlicePtrtoint64((*[]*int64)(&x.Iptrslice), d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WrapSliceInt64 = nil
	} else {
		x.WrapSliceInt64.CodecDecodeSelf(d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.WrapSliceString = nil
	} else {
		x.WrapSliceString.CodecDecodeSelf(d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Msi64 = nil
	} else {
		z.F.DecMapStringInt64X(&x.Msi64, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Msbytes = nil
	} else {
		z.F.DecMapStringBytesX(&x.Msbytes, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Simplef = testSimpleFields{}
	} else {
		x.Simplef.CodecDecodeSelf(d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SstrUi64T = nil
	} else {
		h.decSlicestringUint64T((*[]stringUint64T)(&x.SstrUi64T), d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.MstrUi64T = nil
	} else {
		h.decMapstringPtrtostringUint64T((*map[string]*stringUint64T)(&x.MstrUi64T), d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AS = ""
	} else {
		x.AnonInTestStruc.AS = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AI64 = 0
	} else {
		x.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AI16 = 0
	} else {
		x.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AUi64 = 0
	} else {
		x.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.ASslice = nil
	} else {
		z.F.DecSliceStringX(&x.AnonInTestStruc.ASslice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AI64slice = nil
	} else {
		z.F.DecSliceInt64X(&x.AnonInTestStruc.AI64slice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AUi64slice = nil
	} else {
		z.F.DecSliceUint64X(&x.AnonInTestStruc.AUi64slice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AF64slice = nil
	} else {
		z.F.DecSliceFloat64X(&x.AnonInTestStruc.AF64slice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AF32slice = nil
	} else {
		z.F.DecSliceFloat32X(&x.AnonInTestStruc.AF32slice, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AMSU16 = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.AnonInTestStruc.AMSU16), d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AI64arr0 = [0]int64{}
	} else {
		h.decArray0int64((*[0]int64)(&x.AnonInTestStruc.AI64arr0), d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AI64slice0 = nil
	} else {
		z.F.DecSliceInt64X(&x.AnonInTestStruc.AI64slice0, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AUi64sliceN = nil
	} else {
		z.F.DecSliceUint64X(&x.AnonInTestStruc.AUi64sliceN, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AMSU16N = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.AnonInTestStruc.AMSU16N), d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AnonInTestStruc.AMSU16E = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.AnonInTestStruc.AMSU16E), d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.NotAnon = AnonInTestStruc{}
	} else {
		x.NotAnon.CodecDecodeSelf(d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Nmap = nil
	} else {
		z.F.DecMapStringBoolX(&x.Nmap, d)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Nslice = nil
	} else {
		x.Nslice = r.DecodeBytes(([]byte)(x.Nslice), false)
	}
	yyj83++
	if yyhl83 {
		yyb83 = yyj83 > l
	} else {
		yyb83 = r.CheckBreak()
	}
	if yyb83 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Nint64 != nil { // remove the if-true
			x.Nint64 = nil
		}
	} else {
		if x.Nint64 == nil {
			x.Nint64 = new(int64)
		}

		*x.Nint64 = (int64)(r.DecodeInt64())
	}
	for {
		yyj83++
		if yyhl83 {
			yyb83 = yyj83 > l
		} else {
			yyb83 = r.CheckBreak()
		}
		if yyb83 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj83-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *TestStruc) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn54 bool = x.TestStrucCommon.Nint64 == nil
		var yyn58 bool = x.Nteststruc == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(56)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.TestStrucCommon.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.TestStrucCommon.S))
			}
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I32))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I16))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I8))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I64n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I32n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I16n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I8n))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui64))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui32))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui8))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.TestStrucCommon.F64))
			z.EncWriteArrayElem()
			r.EncodeFloat32(float32(x.TestStrucCommon.F32))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.TestStrucCommon.B))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.By))
			z.EncWriteArrayElem()
			z.F.EncSliceStringV(x.TestStrucCommon.Sslice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt64V(x.TestStrucCommon.I64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt16V(x.TestStrucCommon.I16slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceUint64V(x.TestStrucCommon.Ui64slice, e)
			z.EncWriteArrayElem()
			r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Ui8slice))
			z.EncWriteArrayElem()
			z.F.EncSliceBoolV(x.TestStrucCommon.Bslice, e)
			z.EncWriteArrayElem()
			r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Byslice))
			z.EncWriteArrayElem()
			z.F.EncSliceBytesV(x.TestStrucCommon.BytesSlice, e)
			z.EncWriteArrayElem()
			h.encSlicePtrtoint64(([]*int64)(x.TestStrucCommon.Iptrslice), e)
			z.EncWriteArrayElem()
			x.TestStrucCommon.WrapSliceInt64.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.TestStrucCommon.WrapSliceString.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			z.F.EncMapStringInt64V(x.TestStrucCommon.Msi64, e)
			z.EncWriteArrayElem()
			z.F.EncMapStringBytesV(x.TestStrucCommon.Msbytes, e)
			z.EncWriteArrayElem()
			yy89 := &x.TestStrucCommon.Simplef
			yy89.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			h.encSlicestringUint64T(([]stringUint64T)(x.TestStrucCommon.SstrUi64T), e)
			z.EncWriteArrayElem()
			h.encMapstringPtrtostringUint64T((map[string]*stringUint64T)(x.TestStrucCommon.MstrUi64T), e)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.TestStrucCommon.AnonInTestStruc.AS)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.TestStrucCommon.AnonInTestStruc.AS))
			}
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.AnonInTestStruc.AUi64))
			z.EncWriteArrayElem()
			z.F.EncSliceStringV(x.TestStrucCommon.AnonInTestStruc.ASslice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceFloat64V(x.TestStrucCommon.AnonInTestStruc.AF64slice, e)
			z.EncWriteArrayElem()
			z.F.EncSliceFloat32V(x.TestStrucCommon.AnonInTestStruc.AF32slice, e)
			z.EncWriteArrayElem()
			h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16), e)
			z.EncWriteArrayElem()
			yy103 := &x.TestStrucCommon.AnonInTestStruc.AI64arr0
			h.encArray0int64((*[0]int64)(yy103), e)
			z.EncWriteArrayElem()
			z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice0, e)
			z.EncWriteArrayElem()
			z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, e)
			z.EncWriteArrayElem()
			h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16N), e)
			z.EncWriteArrayElem()
			h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16E), e)
			z.EncWriteArrayElem()
			yy109 := &x.TestStrucCommon.NotAnon
			yy109.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			z.F.EncMapStringBoolV(x.TestStrucCommon.Nmap, e)
			z.EncWriteArrayElem()
			r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Nslice))
			if yyn54 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				yy113 := *x.TestStrucCommon.Nint64
				r.EncodeInt(int64(yy113))
			}
			z.EncWriteArrayElem()
			h.encMapstringPtrtoTestStruc((map[string]*TestStruc)(x.Mtsptr), e)
			z.EncWriteArrayElem()
			h.encMapstringTestStruc((map[string]TestStruc)(x.Mts), e)
			z.EncWriteArrayElem()
			h.encSlicePtrtoTestStruc(([]*TestStruc)(x.Its), e)
			if yyn58 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Nteststruc.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(56)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.TestStrucCommon.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.TestStrucCommon.S))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64n\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I64n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I64n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32n\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I32n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I32n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16n\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I16n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I16n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8n\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I8n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I8n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui32\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui8\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"F64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `F64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.TestStrucCommon.F64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"F32\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `F32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat32(float32(x.TestStrucCommon.F32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.TestStrucCommon.B))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"By\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `By`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.By))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Sslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Sslice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceStringV(x.TestStrucCommon.Sslice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt64V(x.TestStrucCommon.I64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I16slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt16V(x.TestStrucCommon.I16slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceUint64V(x.TestStrucCommon.Ui64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui8slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ui8slice`)
			}
			z.EncWriteMapElemValue()
			r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Ui8slice))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Bslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Bslice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceBoolV(x.TestStrucCommon.Bslice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Byslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Byslice`)
			}
			z.EncWriteMapElemValue()
			r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Byslice))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"BytesSlice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `BytesSlice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceBytesV(x.TestStrucCommon.BytesSlice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Iptrslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Iptrslice`)
			}
			z.EncWriteMapElemValue()
			h.encSlicePtrtoint64(([]*int64)(x.TestStrucCommon.Iptrslice), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WrapSliceInt64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `WrapSliceInt64`)
			}
			z.EncWriteMapElemValue()
			x.TestStrucCommon.WrapSliceInt64.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WrapSliceString\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `WrapSliceString`)
			}
			z.EncWriteMapElemValue()
			x.TestStrucCommon.WrapSliceString.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Msi64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Msi64`)
			}
			z.EncWriteMapElemValue()
			z.F.EncMapStringInt64V(x.TestStrucCommon.Msi64, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Msbytes\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Msbytes`)
			}
			z.EncWriteMapElemValue()
			z.F.EncMapStringBytesV(x.TestStrucCommon.Msbytes, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Simplef\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Simplef`)
			}
			z.EncWriteMapElemValue()
			yy149 := &x.TestStrucCommon.Simplef
			yy149.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"SstrUi64T\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `SstrUi64T`)
			}
			z.EncWriteMapElemValue()
			h.encSlicestringUint64T(([]stringUint64T)(x.TestStrucCommon.SstrUi64T), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"MstrUi64T\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `MstrUi64T`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringPtrtostringUint64T((map[string]*stringUint64T)(x.TestStrucCommon.MstrUi64T), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AS\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AS`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.TestStrucCommon.AnonInTestStruc.AS)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.TestStrucCommon.AnonInTestStruc.AS))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.AnonInTestStruc.AUi64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"ASslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `ASslice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceStringV(x.TestStrucCommon.AnonInTestStruc.ASslice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AF64slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AF64slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceFloat64V(x.TestStrucCommon.AnonInTestStruc.AF64slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AF32slice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AF32slice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceFloat32V(x.TestStrucCommon.AnonInTestStruc.AF32slice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AMSU16\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64arr0\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64arr0`)
			}
			z.EncWriteMapElemValue()
			yy163 := &x.TestStrucCommon.AnonInTestStruc.AI64arr0
			h.encArray0int64((*[0]int64)(yy163), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice0\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AI64slice0`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice0, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64sliceN\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64sliceN`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AMSU16N\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16N`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16N), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AMSU16E\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16E`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16E), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"NotAnon\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `NotAnon`)
			}
			z.EncWriteMapElemValue()
			yy169 := &x.TestStrucCommon.NotAnon
			yy169.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nmap\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Nmap`)
			}
			z.EncWriteMapElemValue()
			z.F.EncMapStringBoolV(x.TestStrucCommon.Nmap, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nslice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Nslice`)
			}
			z.EncWriteMapElemValue()
			r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Nslice))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nint64\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Nint64`)
			}
			z.EncWriteMapElemValue()
			if yyn54 {
				r.EncodeNil()
			} else {
				yy173 := *x.TestStrucCommon.Nint64
				r.EncodeInt(int64(yy173))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Mtsptr\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Mtsptr`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringPtrtoTestStruc((map[string]*TestStruc)(x.Mtsptr), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Mts\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Mts`)
			}
			z.EncWriteMapElemValue()
			h.encMapstringTestStruc((map[string]TestStruc)(x.Mts), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Its\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Its`)
			}
			z.EncWriteMapElemValue()
			h.encSlicePtrtoTestStruc(([]*TestStruc)(x.Its), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nteststruc\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Nteststruc`)
			}
			z.EncWriteMapElemValue()
			if yyn58 {
				r.EncodeNil()
			} else {
				x.Nteststruc.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestStruc) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *TestStruc) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "S":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.S = ""
			} else {
				x.TestStrucCommon.S = (string)(string(r.DecodeStringAsBytes()))
			}
		case "I64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I64 = 0
			} else {
				x.TestStrucCommon.I64 = (int64)(r.DecodeInt64())
			}
		case "I32":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I32 = 0
			} else {
				x.TestStrucCommon.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
			}
		case "I16":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I16 = 0
			} else {
				x.TestStrucCommon.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "I8":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I8 = 0
			} else {
				x.TestStrucCommon.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
			}
		case "I64n":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I64n = 0
			} else {
				x.TestStrucCommon.I64n = (int64)(r.DecodeInt64())
			}
		case "I32n":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I32n = 0
			} else {
				x.TestStrucCommon.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
			}
		case "I16n":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I16n = 0
			} else {
				x.TestStrucCommon.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "I8n":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I8n = 0
			} else {
				x.TestStrucCommon.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
			}
		case "Ui64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui64 = 0
			} else {
				x.TestStrucCommon.Ui64 = (uint64)(r.DecodeUint64())
			}
		case "Ui32":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui32 = 0
			} else {
				x.TestStrucCommon.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
			}
		case "Ui16":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui16 = 0
			} else {
				x.TestStrucCommon.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
			}
		case "Ui8":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui8 = 0
			} else {
				x.TestStrucCommon.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		case "F64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.F64 = 0
			} else {
				x.TestStrucCommon.F64 = (float64)(r.DecodeFloat64())
			}
		case "F32":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.F32 = 0
			} else {
				x.TestStrucCommon.F32 = (float32)(z.DecDecodeFloat32())
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.B = false
			} else {
				x.TestStrucCommon.B = (bool)(r.DecodeBool())
			}
		case "By":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.By = 0
			} else {
				x.TestStrucCommon.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		case "Sslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Sslice = nil
			} else {
				z.F.DecSliceStringX(&x.TestStrucCommon.Sslice, d)
			}
		case "I64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I64slice = nil
			} else {
				z.F.DecSliceInt64X(&x.TestStrucCommon.I64slice, d)
			}
		case "I16slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I16slice = nil
			} else {
				z.F.DecSliceInt16X(&x.TestStrucCommon.I16slice, d)
			}
		case "Ui64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui64slice = nil
			} else {
				z.F.DecSliceUint64X(&x.TestStrucCommon.Ui64slice, d)
			}
		case "Ui8slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui8slice = nil
			} else {
				x.TestStrucCommon.Ui8slice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Ui8slice), false)
			}
		case "Bslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Bslice = nil
			} else {
				z.F.DecSliceBoolX(&x.TestStrucCommon.Bslice, d)
			}
		case "Byslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Byslice = nil
			} else {
				x.TestStrucCommon.Byslice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Byslice), false)
			}
		case "BytesSlice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.BytesSlice = nil
			} else {
				z.F.DecSliceBytesX(&x.TestStrucCommon.BytesSlice, d)
			}
		case "Iptrslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Iptrslice = nil
			} else {
				h.decSlicePtrtoint64((*[]*int64)(&x.TestStrucCommon.Iptrslice), d)
			}
		case "WrapSliceInt64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.WrapSliceInt64 = nil
			} else {
				x.TestStrucCommon.WrapSliceInt64.CodecDecodeSelf(d)
			}
		case "WrapSliceString":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.WrapSliceString = nil
			} else {
				x.TestStrucCommon.WrapSliceString.CodecDecodeSelf(d)
			}
		case "Msi64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Msi64 = nil
			} else {
				z.F.DecMapStringInt64X(&x.TestStrucCommon.Msi64, d)
			}
		case "Msbytes":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Msbytes = nil
			} else {
				z.F.DecMapStringBytesX(&x.TestStrucCommon.Msbytes, d)
			}
		case "Simplef":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Simplef = testSimpleFields{}
			} else {
				x.TestStrucCommon.Simplef.CodecDecodeSelf(d)
			}
		case "SstrUi64T":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.SstrUi64T = nil
			} else {
				h.decSlicestringUint64T((*[]stringUint64T)(&x.TestStrucCommon.SstrUi64T), d)
			}
		case "MstrUi64T":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.MstrUi64T = nil
			} else {
				h.decMapstringPtrtostringUint64T((*map[string]*stringUint64T)(&x.TestStrucCommon.MstrUi64T), d)
			}
		case "AS":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AS = ""
			} else {
				x.TestStrucCommon.AnonInTestStruc.AS = (string)(string(r.DecodeStringAsBytes()))
			}
		case "AI64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI64 = 0
			} else {
				x.TestStrucCommon.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
			}
		case "AI16":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI16 = 0
			} else {
				x.TestStrucCommon.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "AUi64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AUi64 = 0
			} else {
				x.TestStrucCommon.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
			}
		case "ASslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.ASslice = nil
			} else {
				z.F.DecSliceStringX(&x.TestStrucCommon.AnonInTestStruc.ASslice, d)
			}
		case "AI64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI64slice = nil
			} else {
				z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice, d)
			}
		case "AUi64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AUi64slice = nil
			} else {
				z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64slice, d)
			}
		case "AF64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AF64slice = nil
			} else {
				z.F.DecSliceFloat64X(&x.TestStrucCommon.AnonInTestStruc.AF64slice, d)
			}
		case "AF32slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AF32slice = nil
			} else {
				z.F.DecSliceFloat32X(&x.TestStrucCommon.AnonInTestStruc.AF32slice, d)
			}
		case "AMSU16":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AMSU16 = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16), d)
			}
		case "AI64arr0":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI64arr0 = [0]int64{}
			} else {
				h.decArray0int64((*[0]int64)(&x.TestStrucCommon.AnonInTestStruc.AI64arr0), d)
			}
		case "AI64slice0":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI64slice0 = nil
			} else {
				z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice0, d)
			}
		case "AUi64sliceN":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AUi64sliceN = nil
			} else {
				z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, d)
			}
		case "AMSU16N":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AMSU16N = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16N), d)
			}
		case "AMSU16E":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AMSU16E = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16E), d)
			}
		case "NotAnon":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.NotAnon = AnonInTestStruc{}
			} else {
				x.TestStrucCommon.NotAnon.CodecDecodeSelf(d)
			}
		case "Nmap":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Nmap = nil
			} else {
				z.F.DecMapStringBoolX(&x.TestStrucCommon.Nmap, d)
			}
		case "Nslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Nslice = nil
			} else {
				x.TestStrucCommon.Nslice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Nslice), false)
			}
		case "Nint64":
			if r.TryDecodeAsNil() {
				if x.TestStrucCommon.Nint64 != nil { // remove the if-true
					x.TestStrucCommon.Nint64 = nil
				}
			} else {
				if x.TestStrucCommon.Nint64 == nil {
					x.TestStrucCommon.Nint64 = new(int64)
				}

				*x.TestStrucCommon.Nint64 = (int64)(r.DecodeInt64())
			}
		case "Mtsptr":
			if r.TryDecodeAsNil() {
				x.Mtsptr = nil
			} else {
				h.decMapstringPtrtoTestStruc((*map[string]*TestStruc)(&x.Mtsptr), d)
			}
		case "Mts":
			if r.TryDecodeAsNil() {
				x.Mts = nil
			} else {
				h.decMapstringTestStruc((*map[string]TestStruc)(&x.Mts), d)
			}
		case "Its":
			if r.TryDecodeAsNil() {
				x.Its = nil
			} else {
				h.decSlicePtrtoTestStruc((*[]*TestStruc)(&x.Its), d)
			}
		case "Nteststruc":
			if r.TryDecodeAsNil() {
				if x.Nteststruc != nil { // remove the if-true
					x.Nteststruc = nil
				}
			} else {
				if x.Nteststruc == nil {
					x.Nteststruc = new(TestStruc)
				}

				x.Nteststruc.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *TestStruc) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj90 int
	var yyb90 bool
	var yyhl90 bool = l >= 0
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.S = ""
	} else {
		x.TestStrucCommon.S = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I64 = 0
	} else {
		x.TestStrucCommon.I64 = (int64)(r.DecodeInt64())
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I32 = 0
	} else {
		x.TestStrucCommon.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I16 = 0
	} else {
		x.TestStrucCommon.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I8 = 0
	} else {
		x.TestStrucCommon.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I64n = 0
	} else {
		x.TestStrucCommon.I64n = (int64)(r.DecodeInt64())
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I32n = 0
	} else {
		x.TestStrucCommon.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I16n = 0
	} else {
		x.TestStrucCommon.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I8n = 0
	} else {
		x.TestStrucCommon.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui64 = 0
	} else {
		x.TestStrucCommon.Ui64 = (uint64)(r.DecodeUint64())
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui32 = 0
	} else {
		x.TestStrucCommon.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui16 = 0
	} else {
		x.TestStrucCommon.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui8 = 0
	} else {
		x.TestStrucCommon.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.F64 = 0
	} else {
		x.TestStrucCommon.F64 = (float64)(r.DecodeFloat64())
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.F32 = 0
	} else {
		x.TestStrucCommon.F32 = (float32)(z.DecDecodeFloat32())
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.B = false
	} else {
		x.TestStrucCommon.B = (bool)(r.DecodeBool())
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.By = 0
	} else {
		x.TestStrucCommon.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Sslice = nil
	} else {
		z.F.DecSliceStringX(&x.TestStrucCommon.Sslice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I64slice = nil
	} else {
		z.F.DecSliceInt64X(&x.TestStrucCommon.I64slice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I16slice = nil
	} else {
		z.F.DecSliceInt16X(&x.TestStrucCommon.I16slice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui64slice = nil
	} else {
		z.F.DecSliceUint64X(&x.TestStrucCommon.Ui64slice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui8slice = nil
	} else {
		x.TestStrucCommon.Ui8slice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Ui8slice), false)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Bslice = nil
	} else {
		z.F.DecSliceBoolX(&x.TestStrucCommon.Bslice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Byslice = nil
	} else {
		x.TestStrucCommon.Byslice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Byslice), false)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.BytesSlice = nil
	} else {
		z.F.DecSliceBytesX(&x.TestStrucCommon.BytesSlice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Iptrslice = nil
	} else {
		h.decSlicePtrtoint64((*[]*int64)(&x.TestStrucCommon.Iptrslice), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.WrapSliceInt64 = nil
	} else {
		x.TestStrucCommon.WrapSliceInt64.CodecDecodeSelf(d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.WrapSliceString = nil
	} else {
		x.TestStrucCommon.WrapSliceString.CodecDecodeSelf(d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Msi64 = nil
	} else {
		z.F.DecMapStringInt64X(&x.TestStrucCommon.Msi64, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Msbytes = nil
	} else {
		z.F.DecMapStringBytesX(&x.TestStrucCommon.Msbytes, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Simplef = testSimpleFields{}
	} else {
		x.TestStrucCommon.Simplef.CodecDecodeSelf(d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.SstrUi64T = nil
	} else {
		h.decSlicestringUint64T((*[]stringUint64T)(&x.TestStrucCommon.SstrUi64T), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.MstrUi64T = nil
	} else {
		h.decMapstringPtrtostringUint64T((*map[string]*stringUint64T)(&x.TestStrucCommon.MstrUi64T), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AS = ""
	} else {
		x.TestStrucCommon.AnonInTestStruc.AS = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI64 = 0
	} else {
		x.TestStrucCommon.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI16 = 0
	} else {
		x.TestStrucCommon.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AUi64 = 0
	} else {
		x.TestStrucCommon.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.ASslice = nil
	} else {
		z.F.DecSliceStringX(&x.TestStrucCommon.AnonInTestStruc.ASslice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI64slice = nil
	} else {
		z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AUi64slice = nil
	} else {
		z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64slice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AF64slice = nil
	} else {
		z.F.DecSliceFloat64X(&x.TestStrucCommon.AnonInTestStruc.AF64slice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AF32slice = nil
	} else {
		z.F.DecSliceFloat32X(&x.TestStrucCommon.AnonInTestStruc.AF32slice, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AMSU16 = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI64arr0 = [0]int64{}
	} else {
		h.decArray0int64((*[0]int64)(&x.TestStrucCommon.AnonInTestStruc.AI64arr0), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI64slice0 = nil
	} else {
		z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice0, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AUi64sliceN = nil
	} else {
		z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AMSU16N = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16N), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AMSU16E = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16E), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.NotAnon = AnonInTestStruc{}
	} else {
		x.TestStrucCommon.NotAnon.CodecDecodeSelf(d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Nmap = nil
	} else {
		z.F.DecMapStringBoolX(&x.TestStrucCommon.Nmap, d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Nslice = nil
	} else {
		x.TestStrucCommon.Nslice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Nslice), false)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.TestStrucCommon.Nint64 != nil { // remove the if-true
			x.TestStrucCommon.Nint64 = nil
		}
	} else {
		if x.TestStrucCommon.Nint64 == nil {
			x.TestStrucCommon.Nint64 = new(int64)
		}

		*x.TestStrucCommon.Nint64 = (int64)(r.DecodeInt64())
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Mtsptr = nil
	} else {
		h.decMapstringPtrtoTestStruc((*map[string]*TestStruc)(&x.Mtsptr), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Mts = nil
	} else {
		h.decMapstringTestStruc((*map[string]TestStruc)(&x.Mts), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Its = nil
	} else {
		h.decSlicePtrtoTestStruc((*[]*TestStruc)(&x.Its), d)
	}
	yyj90++
	if yyhl90 {
		yyb90 = yyj90 > l
	} else {
		yyb90 = r.CheckBreak()
	}
	if yyb90 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Nteststruc != nil { // remove the if-true
			x.Nteststruc = nil
		}
	} else {
		if x.Nteststruc == nil {
			x.Nteststruc = new(TestStruc)
		}

		x.Nteststruc.CodecDecodeSelf(d)
	}
	for {
		yyj90++
		if yyhl90 {
			yyb90 = yyj90 > l
		} else {
			yyb90 = r.CheckBreak()
		}
		if yyb90 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj90-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *codecgenA) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeStringBytesRaw([]byte(x.ZZ))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"ZZ\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `ZZ`)
			}
			z.EncWriteMapElemValue()
			r.EncodeStringBytesRaw([]byte(x.ZZ))
			z.EncWriteMapEnd()
		}
	}
}

func (x *codecgenA) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *codecgenA) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "ZZ":
			if r.TryDecodeAsNil() {
				x.ZZ = nil
			} else {
				x.ZZ = r.DecodeBytes(([]byte)(x.ZZ), false)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *codecgenA) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ZZ = nil
	} else {
		x.ZZ = r.DecodeBytes(([]byte)(x.ZZ), false)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *codecgenB) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			yy4 := &x.AA
			yy4.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AA\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `AA`)
			}
			z.EncWriteMapElemValue()
			yy6 := &x.AA
			yy6.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *codecgenB) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *codecgenB) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "AA":
			if r.TryDecodeAsNil() {
				x.AA = codecgenA{}
			} else {
				x.AA.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *codecgenB) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.AA = codecgenA{}
	} else {
		x.AA.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *codecgenC) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyq2 = [1]bool{     // should field at this index be written?
			false || codecSelfer19780False() || len(x.BB.AA.ZZ) != 0, // BB
		}
		_ = yyq2
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyq2[0] {
				yy4 := &x.BB
				yy4.CodecEncodeSelf(e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayEnd()
		} else {
			var yynn2 int
			for _, b := range yyq2 {
				if b {
					yynn2++
				}
			}
			z.EncWriteMapStart(yynn2)
			yynn2 = 0
			if yyq2[0] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"BB\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `BB`)
				}
				z.EncWriteMapElemValue()
				yy6 := &x.BB
				yy6.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *codecgenC) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *codecgenC) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "BB":
			if r.TryDecodeAsNil() {
				x.BB = codecgenB{}
			} else {
				x.BB.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *codecgenC) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.BB = codecgenB{}
	} else {
		x.BB.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *TestCodecgenG) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestCodecgenG))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TestCodecgenG\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `TestCodecgenG`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestCodecgenG))
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestCodecgenG) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *TestCodecgenG) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TestCodecgenG":
			if r.TryDecodeAsNil() {
				x.TestCodecgenG = 0
			} else {
				x.TestCodecgenG = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *TestCodecgenG) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestCodecgenG = 0
	} else {
		x.TestCodecgenG = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *codecgenH) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestCodecgenG.TestCodecgenG))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TestCodecgenG\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `TestCodecgenG`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestCodecgenG.TestCodecgenG))
			z.EncWriteMapEnd()
		}
	}
}

func (x *codecgenH) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *codecgenH) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TestCodecgenG":
			if r.TryDecodeAsNil() {
				x.TestCodecgenG.TestCodecgenG = 0
			} else {
				x.TestCodecgenG.TestCodecgenG = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *codecgenH) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestCodecgenG.TestCodecgenG = 0
	} else {
		x.TestCodecgenG.TestCodecgenG = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *codecgenI) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.codecgenH.TestCodecgenG.TestCodecgenG))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TestCodecgenG\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `TestCodecgenG`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.codecgenH.TestCodecgenG.TestCodecgenG))
			z.EncWriteMapEnd()
		}
	}
}

func (x *codecgenI) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *codecgenI) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TestCodecgenG":
			if r.TryDecodeAsNil() {
				x.codecgenH.TestCodecgenG.TestCodecgenG = 0
			} else {
				x.codecgenH.TestCodecgenG.TestCodecgenG = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *codecgenI) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.codecgenH.TestCodecgenG.TestCodecgenG = 0
	} else {
		x.codecgenH.TestCodecgenG.TestCodecgenG = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *codecgenK) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.X))
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.Y)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.Y))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"X\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `X`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.X))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Y\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Y`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.Y)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.Y))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *codecgenK) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *codecgenK) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "X":
			if r.TryDecodeAsNil() {
				x.X = 0
			} else {
				x.X = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		case "Y":
			if r.TryDecodeAsNil() {
				x.Y = ""
			} else {
				x.Y = (string)(string(r.DecodeStringAsBytes()))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *codecgenK) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.X = 0
	} else {
		x.X = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Y = ""
	} else {
		x.Y = (string)(string(r.DecodeStringAsBytes()))
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *codecgenL) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.X))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Y))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"X\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `X`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.X))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Y\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Y`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Y))
			z.EncWriteMapEnd()
		}
	}
}

func (x *codecgenL) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *codecgenL) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "X":
			if r.TryDecodeAsNil() {
				x.X = 0
			} else {
				x.X = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		case "Y":
			if r.TryDecodeAsNil() {
				x.Y = 0
			} else {
				x.Y = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *codecgenL) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.X = 0
	} else {
		x.X = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Y = 0
	} else {
		x.Y = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *codecgenM) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.codecgenK.X))
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.codecgenK.Y)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.codecgenK.Y))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"X\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `X`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.codecgenK.X))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Y\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Y`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.codecgenK.Y)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.codecgenK.Y))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *codecgenM) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *codecgenM) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "X":
			if r.TryDecodeAsNil() {
				x.codecgenK.X = 0
			} else {
				x.codecgenK.X = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		case "Y":
			if r.TryDecodeAsNil() {
				x.codecgenK.Y = ""
			} else {
				x.codecgenK.Y = (string)(string(r.DecodeStringAsBytes()))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *codecgenM) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.codecgenK.X = 0
	} else {
		x.codecgenK.X = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.codecgenK.Y = ""
	} else {
		x.codecgenK.Y = (string)(string(r.DecodeStringAsBytes()))
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	z.DecReadArrayEnd()
}

func (x Bbool) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.EncodeBool(bool(x))
}

func (x *Bbool) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	*x = (Bbool)(r.DecodeBool())
}

func (x *Aarray) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encAarray((*Aarray)(x), e)
	}
}

func (x *Aarray) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decAarray((*Aarray)(x), d)
}

func (x Sstring) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if z.EncBasicHandle().StringToRaw {
		r.EncodeStringBytesRaw(z.BytesView(string(x)))
	} else {
		r.EncodeStringEnc(codecSelferCcUTF819780, string(x))
	}
}

func (x *Sstring) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	*x = (Sstring)(string(r.DecodeStringAsBytes()))
}

func (x *Sstructsmall) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.A))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"A\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `A`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.A))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Sstructsmall) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *Sstructsmall) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "A":
			if r.TryDecodeAsNil() {
				x.A = 0
			} else {
				x.A = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *Sstructsmall) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = r.CheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.A = 0
	} else {
		x.A = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = r.CheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *Sstructbig) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn5 bool = x.Ssmallptr == nil
		var yyn6 bool = x.Ssmall == nil
		var yyn7 bool = x.Sptr == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.A))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.B))
			if yyn5 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Ssmallptr.CodecEncodeSelf(e)
			}
			if yyn6 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Ssmall.CodecEncodeSelf(e)
			}
			if yyn7 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Sptr.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"A\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `A`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.A))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.B))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ssmallptr\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ssmallptr`)
			}
			z.EncWriteMapElemValue()
			if yyn5 {
				r.EncodeNil()
			} else {
				x.Ssmallptr.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ssmall\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ssmall`)
			}
			z.EncWriteMapElemValue()
			if yyn6 {
				r.EncodeNil()
			} else {
				x.Ssmall.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Sptr\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Sptr`)
			}
			z.EncWriteMapElemValue()
			if yyn7 {
				r.EncodeNil()
			} else {
				x.Sptr.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *Sstructbig) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *Sstructbig) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "A":
			if r.TryDecodeAsNil() {
				x.A = 0
			} else {
				x.A = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.B = false
			} else {
				x.B = (bool)(r.DecodeBool())
			}
		case "Ssmallptr":
			if r.TryDecodeAsNil() {
				if x.Ssmallptr != nil { // remove the if-true
					x.Ssmallptr = nil
				}
			} else {
				if x.Ssmallptr == nil {
					x.Ssmallptr = new(Sstructsmall)
				}

				x.Ssmallptr.CodecDecodeSelf(d)
			}
		case "Ssmall":
			if r.TryDecodeAsNil() {
				if x.Ssmall != nil { // remove the if-true
					x.Ssmall = nil
				}
			} else {
				if x.Ssmall == nil {
					x.Ssmall = new(Sstructsmall)
				}

				x.Ssmall.CodecDecodeSelf(d)
			}
		case "Sptr":
			if r.TryDecodeAsNil() {
				if x.Sptr != nil { // remove the if-true
					x.Sptr = nil
				}
			} else {
				if x.Sptr == nil {
					x.Sptr = new(Sstructbig)
				}

				x.Sptr.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *Sstructbig) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.A = 0
	} else {
		x.A = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.B = false
	} else {
		x.B = (bool)(r.DecodeBool())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Ssmallptr != nil { // remove the if-true
			x.Ssmallptr = nil
		}
	} else {
		if x.Ssmallptr == nil {
			x.Ssmallptr = new(Sstructsmall)
		}

		x.Ssmallptr.CodecDecodeSelf(d)
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Ssmall != nil { // remove the if-true
			x.Ssmall = nil
		}
	} else {
		if x.Ssmall == nil {
			x.Ssmall = new(Sstructsmall)
		}

		x.Ssmall.CodecDecodeSelf(d)
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Sptr != nil { // remove the if-true
			x.Sptr = nil
		}
	} else {
		if x.Sptr == nil {
			x.Sptr = new(Sstructbig)
		}

		x.Sptr.CodecDecodeSelf(d)
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = r.CheckBreak()
		}
		if yyb9 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *SstructbigMapBySlice) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = true // struct tag has 'toArray'
		var yyn5 bool = x.Ssmallptr == nil
		var yyn6 bool = x.Ssmall == nil
		var yyn7 bool = x.Sptr == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.A))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.B))
			if yyn5 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Ssmallptr.CodecEncodeSelf(e)
			}
			if yyn6 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Ssmall.CodecEncodeSelf(e)
			}
			if yyn7 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Sptr.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"A\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `A`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.A))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.B))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ssmallptr\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ssmallptr`)
			}
			z.EncWriteMapElemValue()
			if yyn5 {
				r.EncodeNil()
			} else {
				x.Ssmallptr.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ssmall\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ssmall`)
			}
			z.EncWriteMapElemValue()
			if yyn6 {
				r.EncodeNil()
			} else {
				x.Ssmall.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Sptr\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Sptr`)
			}
			z.EncWriteMapElemValue()
			if yyn7 {
				r.EncodeNil()
			} else {
				x.Sptr.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *SstructbigMapBySlice) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *SstructbigMapBySlice) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "A":
			if r.TryDecodeAsNil() {
				x.A = 0
			} else {
				x.A = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.B = false
			} else {
				x.B = (bool)(r.DecodeBool())
			}
		case "Ssmallptr":
			if r.TryDecodeAsNil() {
				if x.Ssmallptr != nil { // remove the if-true
					x.Ssmallptr = nil
				}
			} else {
				if x.Ssmallptr == nil {
					x.Ssmallptr = new(Sstructsmall)
				}

				x.Ssmallptr.CodecDecodeSelf(d)
			}
		case "Ssmall":
			if r.TryDecodeAsNil() {
				if x.Ssmall != nil { // remove the if-true
					x.Ssmall = nil
				}
			} else {
				if x.Ssmall == nil {
					x.Ssmall = new(Sstructsmall)
				}

				x.Ssmall.CodecDecodeSelf(d)
			}
		case "Sptr":
			if r.TryDecodeAsNil() {
				if x.Sptr != nil { // remove the if-true
					x.Sptr = nil
				}
			} else {
				if x.Sptr == nil {
					x.Sptr = new(Sstructbig)
				}

				x.Sptr.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *SstructbigMapBySlice) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.A = 0
	} else {
		x.A = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.B = false
	} else {
		x.B = (bool)(r.DecodeBool())
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Ssmallptr != nil { // remove the if-true
			x.Ssmallptr = nil
		}
	} else {
		if x.Ssmallptr == nil {
			x.Ssmallptr = new(Sstructsmall)
		}

		x.Ssmallptr.CodecDecodeSelf(d)
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Ssmall != nil { // remove the if-true
			x.Ssmall = nil
		}
	} else {
		if x.Ssmall == nil {
			x.Ssmall = new(Sstructsmall)
		}

		x.Ssmall.CodecDecodeSelf(d)
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = r.CheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Sptr != nil { // remove the if-true
			x.Sptr = nil
		}
	} else {
		if x.Sptr == nil {
			x.Sptr = new(Sstructbig)
		}

		x.Sptr.CodecDecodeSelf(d)
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = r.CheckBreak()
		}
		if yyb9 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *tLowerFirstLetter) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I))
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *tLowerFirstLetter) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *tLowerFirstLetter) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "I":
			if r.TryDecodeAsNil() {
				x.I = 0
			} else {
				x.I = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
		case "S":
			if r.TryDecodeAsNil() {
				x.S = ""
			} else {
				x.S = (string)(string(r.DecodeStringAsBytes()))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *tLowerFirstLetter) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I = 0
	} else {
		x.I = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.S = ""
	} else {
		x.S = (string)(string(r.DecodeStringAsBytes()))
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	z.DecReadArrayEnd()
}

func (x wrapInt64) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.EncodeInt(int64(x))
}

func (x *wrapInt64) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	*x = (wrapInt64)(r.DecodeInt64())
}

func (x wrapUint8) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.EncodeUint(uint64(x))
}

func (x *wrapUint8) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	*x = (wrapUint8)(z.C.UintV(r.DecodeUint64(), 8))
}

func (x wrapBytes) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encwrapBytes((wrapBytes)(x), e)
	}
}

func (x *wrapBytes) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decwrapBytes((*wrapBytes)(x), d)
}

func (x *AnonInTestStrucIntf) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn7 bool = x.Tptr == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			z.F.EncSliceIntfV(x.Islice, e)
			z.EncWriteArrayElem()
			z.F.EncMapStringIntfV(x.Ms, e)
			z.EncWriteArrayElem()
			z.EncFallback(x.Nintf)
			z.EncWriteArrayElem()
			if !z.EncBasicHandle().TimeNotBuiltin {
				r.EncodeTime(x.T)
			} else if yyxt11 := z.Extension(z.I2Rtid(x.T)); yyxt11 != nil {
				z.EncExtension(x.T, yyxt11)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.T)
			} else if !z.EncBinary() && z.IsJSONHandle() {
				z.EncJSONMarshal(x.T)
			} else {
				z.EncFallback(x.T)
			}
			if yyn7 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				yy12 := *x.Tptr
				if !z.EncBasicHandle().TimeNotBuiltin {
					r.EncodeTime(yy12)
				} else if yyxt13 := z.Extension(z.I2Rtid(yy12)); yyxt13 != nil {
					z.EncExtension(yy12, yyxt13)
				} else if z.EncBinary() {
					z.EncBinaryMarshal(yy12)
				} else if !z.EncBinary() && z.IsJSONHandle() {
					z.EncJSONMarshal(yy12)
				} else {
					z.EncFallback(yy12)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Islice\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Islice`)
			}
			z.EncWriteMapElemValue()
			z.F.EncSliceIntfV(x.Islice, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ms\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Ms`)
			}
			z.EncWriteMapElemValue()
			z.F.EncMapStringIntfV(x.Ms, e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nintf\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Nintf`)
			}
			z.EncWriteMapElemValue()
			z.EncFallback(x.Nintf)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"T\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `T`)
			}
			z.EncWriteMapElemValue()
			if !z.EncBasicHandle().TimeNotBuiltin {
				r.EncodeTime(x.T)
			} else if yyxt17 := z.Extension(z.I2Rtid(x.T)); yyxt17 != nil {
				z.EncExtension(x.T, yyxt17)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.T)
			} else if !z.EncBinary() && z.IsJSONHandle() {
				z.EncJSONMarshal(x.T)
			} else {
				z.EncFallback(x.T)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Tptr\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `Tptr`)
			}
			z.EncWriteMapElemValue()
			if yyn7 {
				r.EncodeNil()
			} else {
				yy18 := *x.Tptr
				if !z.EncBasicHandle().TimeNotBuiltin {
					r.EncodeTime(yy18)
				} else if yyxt19 := z.Extension(z.I2Rtid(yy18)); yyxt19 != nil {
					z.EncExtension(yy18, yyxt19)
				} else if z.EncBinary() {
					z.EncBinaryMarshal(yy18)
				} else if !z.EncBinary() && z.IsJSONHandle() {
					z.EncJSONMarshal(yy18)
				} else {
					z.EncFallback(yy18)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *AnonInTestStrucIntf) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *AnonInTestStrucIntf) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Islice":
			if r.TryDecodeAsNil() {
				x.Islice = nil
			} else {
				z.F.DecSliceIntfX(&x.Islice, d)
			}
		case "Ms":
			if r.TryDecodeAsNil() {
				x.Ms = nil
			} else {
				z.F.DecMapStringIntfX(&x.Ms, d)
			}
		case "Nintf":
			if r.TryDecodeAsNil() {
				x.Nintf = nil
			} else {
				z.DecFallback(&x.Nintf, true)
			}
		case "T":
			if r.TryDecodeAsNil() {
				x.T = time.Time{}
			} else {
				if !z.DecBasicHandle().TimeNotBuiltin {
					x.T = r.DecodeTime()
				} else if yyxt11 := z.Extension(z.I2Rtid(x.T)); yyxt11 != nil {
					z.DecExtension(x.T, yyxt11)
				} else if z.DecBinary() {
					z.DecBinaryUnmarshal(&x.T)
				} else if !z.DecBinary() && z.IsJSONHandle() {
					z.DecJSONUnmarshal(&x.T)
				} else {
					z.DecFallback(&x.T, false)
				}
			}
		case "Tptr":
			if r.TryDecodeAsNil() {
				if x.Tptr != nil { // remove the if-true
					x.Tptr = nil
				}
			} else {
				if x.Tptr == nil {
					x.Tptr = new(time.Time)
				}

				if !z.DecBasicHandle().TimeNotBuiltin {
					*x.Tptr = r.DecodeTime()
				} else if yyxt13 := z.Extension(z.I2Rtid(x.Tptr)); yyxt13 != nil {
					z.DecExtension(x.Tptr, yyxt13)
				} else if z.DecBinary() {
					z.DecBinaryUnmarshal(x.Tptr)
				} else if !z.DecBinary() && z.IsJSONHandle() {
					z.DecJSONUnmarshal(x.Tptr)
				} else {
					z.DecFallback(x.Tptr, false)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *AnonInTestStrucIntf) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj14 int
	var yyb14 bool
	var yyhl14 bool = l >= 0
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Islice = nil
	} else {
		z.F.DecSliceIntfX(&x.Islice, d)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ms = nil
	} else {
		z.F.DecMapStringIntfX(&x.Ms, d)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Nintf = nil
	} else {
		z.DecFallback(&x.Nintf, true)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.T = time.Time{}
	} else {
		if !z.DecBasicHandle().TimeNotBuiltin {
			x.T = r.DecodeTime()
		} else if yyxt22 := z.Extension(z.I2Rtid(x.T)); yyxt22 != nil {
			z.DecExtension(x.T, yyxt22)
		} else if z.DecBinary() {
			z.DecBinaryUnmarshal(&x.T)
		} else if !z.DecBinary() && z.IsJSONHandle() {
			z.DecJSONUnmarshal(&x.T)
		} else {
			z.DecFallback(&x.T, false)
		}
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = r.CheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Tptr != nil { // remove the if-true
			x.Tptr = nil
		}
	} else {
		if x.Tptr == nil {
			x.Tptr = new(time.Time)
		}

		if !z.DecBasicHandle().TimeNotBuiltin {
			*x.Tptr = r.DecodeTime()
		} else if yyxt24 := z.Extension(z.I2Rtid(x.Tptr)); yyxt24 != nil {
			z.DecExtension(x.Tptr, yyxt24)
		} else if z.DecBinary() {
			z.DecBinaryUnmarshal(x.Tptr)
		} else if !z.DecBinary() && z.IsJSONHandle() {
			z.DecJSONUnmarshal(x.Tptr)
		} else {
			z.DecFallback(x.Tptr, false)
		}
	}
	for {
		yyj14++
		if yyhl14 {
			yyb14 = yyj14 > l
		} else {
			yyb14 = r.CheckBreak()
		}
		if yyb14 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj14-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *missingFielderT1) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.B))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.B))
			z.EncWriteMapEnd()
		}
	}
}

func (x *missingFielderT1) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *missingFielderT1) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "S":
			if r.TryDecodeAsNil() {
				x.S = ""
			} else {
				x.S = (string)(string(r.DecodeStringAsBytes()))
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.B = false
			} else {
				x.B = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *missingFielderT1) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.S = ""
	} else {
		x.S = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.B = false
	} else {
		x.B = (bool)(r.DecodeBool())
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *missingFielderT2) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.B))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.F))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.B))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"F\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `F`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.F))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I))
			z.EncWriteMapEnd()
		}
	}
}

func (x *missingFielderT2) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *missingFielderT2) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "S":
			if r.TryDecodeAsNil() {
				x.S = ""
			} else {
				x.S = (string)(string(r.DecodeStringAsBytes()))
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.B = false
			} else {
				x.B = (bool)(r.DecodeBool())
			}
		case "F":
			if r.TryDecodeAsNil() {
				x.F = 0
			} else {
				x.F = (float64)(r.DecodeFloat64())
			}
		case "I":
			if r.TryDecodeAsNil() {
				x.I = 0
			} else {
				x.I = (int64)(r.DecodeInt64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *missingFielderT2) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.S = ""
	} else {
		x.S = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.B = false
	} else {
		x.B = (bool)(r.DecodeBool())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.F = 0
	} else {
		x.F = (float64)(r.DecodeFloat64())
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I = 0
	} else {
		x.I = (int64)(r.DecodeInt64())
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *testSelfExtHelper) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.B))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.S))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.B))
			z.EncWriteMapEnd()
		}
	}
}

func (x *testSelfExtHelper) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *testSelfExtHelper) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "S":
			if r.TryDecodeAsNil() {
				x.S = ""
			} else {
				x.S = (string)(string(r.DecodeStringAsBytes()))
			}
		case "I":
			if r.TryDecodeAsNil() {
				x.I = 0
			} else {
				x.I = (int64)(r.DecodeInt64())
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.B = false
			} else {
				x.B = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *testSelfExtHelper) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.S = ""
	} else {
		x.S = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.I = 0
	} else {
		x.I = (int64)(r.DecodeInt64())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.B = false
	} else {
		x.B = (bool)(r.DecodeBool())
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *TestSelfExtImpl) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.testSelfExtHelper.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.testSelfExtHelper.S))
			}
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.testSelfExtHelper.I))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.testSelfExtHelper.B))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.testSelfExtHelper.S)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.testSelfExtHelper.S))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `I`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.testSelfExtHelper.I))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.testSelfExtHelper.B))
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestSelfExtImpl) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *TestSelfExtImpl) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "S":
			if r.TryDecodeAsNil() {
				x.testSelfExtHelper.S = ""
			} else {
				x.testSelfExtHelper.S = (string)(string(r.DecodeStringAsBytes()))
			}
		case "I":
			if r.TryDecodeAsNil() {
				x.testSelfExtHelper.I = 0
			} else {
				x.testSelfExtHelper.I = (int64)(r.DecodeInt64())
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.testSelfExtHelper.B = false
			} else {
				x.testSelfExtHelper.B = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *TestSelfExtImpl) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.testSelfExtHelper.S = ""
	} else {
		x.testSelfExtHelper.S = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.testSelfExtHelper.I = 0
	} else {
		x.testSelfExtHelper.I = (int64)(r.DecodeInt64())
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = r.CheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.testSelfExtHelper.B = false
	} else {
		x.testSelfExtHelper.B = (bool)(r.DecodeBool())
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = r.CheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *TestSelfExtImpl2) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.M)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.M))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.O))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"M\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `M`)
			}
			z.EncWriteMapElemValue()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(x.M)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(x.M))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"O\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `O`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.O))
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestSelfExtImpl2) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *TestSelfExtImpl2) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "M":
			if r.TryDecodeAsNil() {
				x.M = ""
			} else {
				x.M = (string)(string(r.DecodeStringAsBytes()))
			}
		case "O":
			if r.TryDecodeAsNil() {
				x.O = false
			} else {
				x.O = (bool)(r.DecodeBool())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *TestSelfExtImpl2) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.M = ""
	} else {
		x.M = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = r.CheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.O = false
	} else {
		x.O = (bool)(r.DecodeBool())
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = r.CheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *TestTwoNakedInterfaces) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			z.EncFallback(x.A)
			z.EncWriteArrayElem()
			z.EncFallback(x.B)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"A\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `A`)
			}
			z.EncWriteMapElemValue()
			z.EncFallback(x.A)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
			}
			z.EncWriteMapElemValue()
			z.EncFallback(x.B)
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestTwoNakedInterfaces) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *TestTwoNakedInterfaces) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "A":
			if r.TryDecodeAsNil() {
				x.A = nil
			} else {
				z.DecFallback(&x.A, true)
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.B = nil
			} else {
				z.DecFallback(&x.B, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *TestTwoNakedInterfaces) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.A = nil
	} else {
		z.DecFallback(&x.A, true)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.B = nil
	} else {
		z.DecFallback(&x.B, true)
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	z.DecReadArrayEnd()
}

func (x *TestStrucFlex) CodecEncodeSelf(e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyq2 = [77]bool{    // should field at this index be written?
			x.S != "",                   // S
			x.I64 != 0,                  // I64
			x.I32 != 0,                  // I32
			x.I16 != 0,                  // I16
			x.I8 != 0,                   // I8
			x.I64n != 0,                 // I64n
			x.I32n != 0,                 // I32n
			x.I16n != 0,                 // I16n
			x.I8n != 0,                  // I8n
			x.Ui64 != 0,                 // Ui64
			x.Ui32 != 0,                 // Ui32
			x.Ui16 != 0,                 // Ui16
			x.Ui8 != 0,                  // Ui8
			x.F64 != 0,                  // F64
			x.F32 != 0,                  // F32
			x.B,                         // B
			x.By != 0,                   // By
			len(x.Sslice) != 0,          // Sslice
			len(x.I64slice) != 0,        // I64slice
			len(x.I16slice) != 0,        // I16slice
			len(x.Ui64slice) != 0,       // Ui64slice
			len(x.Ui8slice) != 0,        // Ui8slice
			len(x.Bslice) != 0,          // Bslice
			len(x.Byslice) != 0,         // Byslice
			len(x.BytesSlice) != 0,      // BytesSlice
			len(x.Iptrslice) != 0,       // Iptrslice
			len(x.WrapSliceInt64) != 0,  // WrapSliceInt64
			len(x.WrapSliceString) != 0, // WrapSliceString
			len(x.Msi64) != 0,           // Msi64
			len(x.Msbytes) != 0,         // Msbytes
			false || x.Simplef.S != "" || x.Simplef.I64 != 0 || x.Simplef.I8 != 0 || x.Simplef.Ui64 != 0 || x.Simplef.Ui8 != 0 || x.Simplef.F64 != 0 || x.Simplef.F32 != 0 || x.Simplef.B || len(x.Simplef.Sslice) != 0 || len(x.Simplef.I16slice) != 0 || len(x.Simplef.Ui64slice) != 0 || len(x.Simplef.Ui8slice) != 0 || len(x.Simplef.Bslice) != 0 || len(x.Simplef.Iptrslice) != 0 || len(x.Simplef.WrapSliceInt64) != 0 || len(x.Simplef.WrapSliceString) != 0 || len(x.Simplef.Msi64) != 0, // Simplef
			len(x.SstrUi64T) != 0,   // SstrUi64T
			len(x.MstrUi64T) != 0,   // MstrUi64T
			x.AS != "",              // AS
			x.AI64 != 0,             // AI64
			x.AI16 != 0,             // AI16
			x.AUi64 != 0,            // AUi64
			len(x.ASslice) != 0,     // ASslice
			len(x.AI64slice) != 0,   // AI64slice
			len(x.AUi64slice) != 0,  // AUi64slice
			len(x.AF64slice) != 0,   // AF64slice
			len(x.AF32slice) != 0,   // AF32slice
			len(x.AMSU16) != 0,      // AMSU16
			len(x.AI64arr0) != 0,    // AI64arr0
			len(x.AI64slice0) != 0,  // AI64slice0
			len(x.AUi64sliceN) != 0, // AUi64sliceN
			len(x.AMSU16N) != 0,     // AMSU16N
			len(x.AMSU16E) != 0,     // AMSU16E
			false || x.NotAnon.AS != "" || x.NotAnon.AI64 != 0 || x.NotAnon.AI16 != 0 || x.NotAnon.AUi64 != 0 || len(x.NotAnon.ASslice) != 0 || len(x.NotAnon.AI64slice) != 0 || len(x.NotAnon.AUi64slice) != 0 || len(x.NotAnon.AF64slice) != 0 || len(x.NotAnon.AF32slice) != 0 || len(x.NotAnon.AMSU16) != 0 || len(x.NotAnon.AI64arr0) != 0 || len(x.NotAnon.AI64slice0) != 0 || len(x.NotAnon.AUi64sliceN) != 0 || len(x.NotAnon.AMSU16N) != 0 || len(x.NotAnon.AMSU16E) != 0, // NotAnon
			len(x.Nmap) != 0,           // Nmap
			len(x.Nslice) != 0,         // Nslice
			x.Nint64 != nil,            // Nint64
			len(x.Chstr) != 0,          // Chstr
			len(x.Mis) != 0,            // Mis
			len(x.Mbu64) != 0,          // Mbu64
			len(x.Miwu64s) != 0,        // Miwu64s
			len(x.Mfwss) != 0,          // Mfwss
			len(x.Mf32wss) != 0,        // Mf32wss
			len(x.Mui2wss) != 0,        // Mui2wss
			len(x.Msu2wss) != 0,        // Msu2wss
			x.Ci64 != 0,                // Ci64
			len(x.Swrapbytes) != 0,     // Swrapbytes
			len(x.Swrapuint8) != 0,     // Swrapuint8
			len(x.ArrStrUi64T) != 0,    // ArrStrUi64T
			len(x.Ui64array) != 0,      // Ui64array
			len(x.Ui64slicearray) != 0, // Ui64slicearray
			len(x.SintfAarray) != 0,    // SintfAarray
			len(x.MstrUi64TSelf) != 0,  // MstrUi64TSelf
			x.AnonInTestStrucIntf != nil && len(x.Islice) != 0, // Islice
			x.AnonInTestStrucIntf != nil && len(x.Ms) != 0,     // Ms
			x.AnonInTestStrucIntf != nil && x.Nintf != nil,     // Nintf
			x.AnonInTestStrucIntf != nil && !(x.T.IsZero()),    // T
			x.AnonInTestStrucIntf != nil && x.Tptr != nil,      // Tptr
			len(x.Mtsptr) != 0,  // Mtsptr
			len(x.Mts) != 0,     // Mts
			len(x.Its) != 0,     // Its
			x.Nteststruc != nil, // Nteststruc
		}
		_ = yyq2
		var yyn54 bool = x.TestStrucCommon.Nint64 == nil
		var yyn71 bool = x.AnonInTestStrucIntf == nil
		var yyn72 bool = x.AnonInTestStrucIntf == nil
		var yyn73 bool = x.AnonInTestStrucIntf == nil
		var yyn74 bool = x.AnonInTestStrucIntf == nil
		var yyn75 bool = x.AnonInTestStrucIntf == nil || x.AnonInTestStrucIntf.Tptr == nil
		var yyn79 bool = x.Nteststruc == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(77)
			z.EncWriteArrayElem()
			if yyq2[0] {
				if z.EncBasicHandle().StringToRaw {
					r.EncodeStringBytesRaw(z.BytesView(string(x.TestStrucCommon.S)))
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, string(x.TestStrucCommon.S))
				}
			} else {
				if z.EncBasicHandle().StringToRaw {
					r.EncodeStringBytesRaw([]byte{})
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, "")
				}
			}
			z.EncWriteArrayElem()
			if yyq2[1] {
				r.EncodeInt(int64(x.TestStrucCommon.I64))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[2] {
				r.EncodeInt(int64(x.TestStrucCommon.I32))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[3] {
				r.EncodeInt(int64(x.TestStrucCommon.I16))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[4] {
				r.EncodeInt(int64(x.TestStrucCommon.I8))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[5] {
				r.EncodeInt(int64(x.TestStrucCommon.I64n))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[6] {
				r.EncodeInt(int64(x.TestStrucCommon.I32n))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[7] {
				r.EncodeInt(int64(x.TestStrucCommon.I16n))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[8] {
				r.EncodeInt(int64(x.TestStrucCommon.I8n))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[9] {
				r.EncodeUint(uint64(x.TestStrucCommon.Ui64))
			} else {
				r.EncodeUint(0)
			}
			z.EncWriteArrayElem()
			if yyq2[10] {
				r.EncodeUint(uint64(x.TestStrucCommon.Ui32))
			} else {
				r.EncodeUint(0)
			}
			z.EncWriteArrayElem()
			if yyq2[11] {
				r.EncodeUint(uint64(x.TestStrucCommon.Ui16))
			} else {
				r.EncodeUint(0)
			}
			z.EncWriteArrayElem()
			if yyq2[12] {
				r.EncodeUint(uint64(x.TestStrucCommon.Ui8))
			} else {
				r.EncodeUint(0)
			}
			z.EncWriteArrayElem()
			if yyq2[13] {
				r.EncodeFloat64(float64(x.TestStrucCommon.F64))
			} else {
				r.EncodeFloat64(0)
			}
			z.EncWriteArrayElem()
			if yyq2[14] {
				r.EncodeFloat32(float32(x.TestStrucCommon.F32))
			} else {
				r.EncodeFloat32(0)
			}
			z.EncWriteArrayElem()
			if yyq2[15] {
				r.EncodeBool(bool(x.TestStrucCommon.B))
			} else {
				r.EncodeBool(false)
			}
			z.EncWriteArrayElem()
			if yyq2[16] {
				r.EncodeUint(uint64(x.TestStrucCommon.By))
			} else {
				r.EncodeUint(0)
			}
			z.EncWriteArrayElem()
			if yyq2[17] {
				z.F.EncSliceStringV(x.TestStrucCommon.Sslice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[18] {
				z.F.EncSliceInt64V(x.TestStrucCommon.I64slice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[19] {
				z.F.EncSliceInt16V(x.TestStrucCommon.I16slice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[20] {
				z.F.EncSliceUint64V(x.TestStrucCommon.Ui64slice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[21] {
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Ui8slice))
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[22] {
				z.F.EncSliceBoolV(x.TestStrucCommon.Bslice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[23] {
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Byslice))
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[24] {
				z.F.EncSliceBytesV(x.TestStrucCommon.BytesSlice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[25] {
				h.encSlicePtrtoint64(([]*int64)(x.TestStrucCommon.Iptrslice), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[26] {
				x.TestStrucCommon.WrapSliceInt64.CodecEncodeSelf(e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[27] {
				x.TestStrucCommon.WrapSliceString.CodecEncodeSelf(e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[28] {
				z.F.EncMapStringInt64V(x.TestStrucCommon.Msi64, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[29] {
				z.F.EncMapStringBytesV(x.TestStrucCommon.Msbytes, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[30] {
				yy110 := &x.TestStrucCommon.Simplef
				yy110.CodecEncodeSelf(e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[31] {
				h.encSlicestringUint64T(([]stringUint64T)(x.TestStrucCommon.SstrUi64T), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[32] {
				h.encMapstringPtrtostringUint64T((map[string]*stringUint64T)(x.TestStrucCommon.MstrUi64T), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[33] {
				if z.EncBasicHandle().StringToRaw {
					r.EncodeStringBytesRaw(z.BytesView(string(x.TestStrucCommon.AnonInTestStruc.AS)))
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, string(x.TestStrucCommon.AnonInTestStruc.AS))
				}
			} else {
				if z.EncBasicHandle().StringToRaw {
					r.EncodeStringBytesRaw([]byte{})
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, "")
				}
			}
			z.EncWriteArrayElem()
			if yyq2[34] {
				r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI64))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[35] {
				r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI16))
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[36] {
				r.EncodeUint(uint64(x.TestStrucCommon.AnonInTestStruc.AUi64))
			} else {
				r.EncodeUint(0)
			}
			z.EncWriteArrayElem()
			if yyq2[37] {
				z.F.EncSliceStringV(x.TestStrucCommon.AnonInTestStruc.ASslice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[38] {
				z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[39] {
				z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64slice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[40] {
				z.F.EncSliceFloat64V(x.TestStrucCommon.AnonInTestStruc.AF64slice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[41] {
				z.F.EncSliceFloat32V(x.TestStrucCommon.AnonInTestStruc.AF32slice, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[42] {
				h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[43] {
				yy124 := &x.TestStrucCommon.AnonInTestStruc.AI64arr0
				h.encArray0int64((*[0]int64)(yy124), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[44] {
				z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice0, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[45] {
				z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[46] {
				h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16N), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[47] {
				h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16E), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[48] {
				yy130 := &x.TestStrucCommon.NotAnon
				yy130.CodecEncodeSelf(e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[49] {
				z.F.EncMapStringBoolV(x.TestStrucCommon.Nmap, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[50] {
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Nslice))
			} else {
				r.EncodeNil()
			}
			if yyn54 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyq2[51] {
					yy134 := *x.TestStrucCommon.Nint64
					r.EncodeInt(int64(yy134))
				} else {
					r.EncodeNil()
				}
			}
			z.EncWriteArrayElem()
			if yyq2[52] {
				h.encChanstring((chan string)(x.Chstr), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[53] {
				z.F.EncMapIntStringV(x.Mis, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[54] {
				h.encMapboolc3RydWN0IHt9((map[bool]struct{})(x.Mbu64), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[55] {
				h.encMapintwrapUint64Slice((map[int]wrapUint64Slice)(x.Miwu64s), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[56] {
				h.encMapfloat64wrapStringSlice((map[float64]wrapStringSlice)(x.Mfwss), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[57] {
				h.encMapfloat32wrapStringSlice((map[float32]wrapStringSlice)(x.Mf32wss), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[58] {
				h.encMapuint64wrapStringSlice((map[uint64]wrapStringSlice)(x.Mui2wss), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[59] {
				h.encMapstringUint64TwrapStringSlice((map[stringUint64T]wrapStringSlice)(x.Msu2wss), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[60] {
				x.Ci64.CodecEncodeSelf(e)
			} else {
				r.EncodeInt(0)
			}
			z.EncWriteArrayElem()
			if yyq2[61] {
				h.encSlicewrapBytes(([]wrapBytes)(x.Swrapbytes), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[62] {
				h.encSlicewrapUint8(([]wrapUint8)(x.Swrapuint8), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[63] {
				yy147 := &x.ArrStrUi64T
				h.encArray4stringUint64T((*[4]stringUint64T)(yy147), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[64] {
				yy149 := &x.Ui64array
				h.encArray4uint64((*[4]uint64)(yy149), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[65] {
				h.encSlicePtrtoArray4uint64(([]*[4]uint64)(x.Ui64slicearray), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[66] {
				z.F.EncSliceIntfV(x.SintfAarray, e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[67] {
				h.encMapstringUint64TPtrtostringUint64T((map[stringUint64T]*stringUint64T)(x.MstrUi64TSelf), e)
			} else {
				r.EncodeNil()
			}
			if yyn71 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyq2[68] {
					z.F.EncSliceIntfV(x.AnonInTestStrucIntf.Islice, e)
				} else {
					r.EncodeNil()
				}
			}
			if yyn72 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyq2[69] {
					z.F.EncMapStringIntfV(x.AnonInTestStrucIntf.Ms, e)
				} else {
					r.EncodeNil()
				}
			}
			if yyn73 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyq2[70] {
					z.EncFallback(x.AnonInTestStrucIntf.Nintf)
				} else {
					r.EncodeNil()
				}
			}
			if yyn74 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyq2[71] {
					if !z.EncBasicHandle().TimeNotBuiltin {
						r.EncodeTime(x.AnonInTestStrucIntf.T)
					} else if yyxt157 := z.Extension(z.I2Rtid(x.AnonInTestStrucIntf.T)); yyxt157 != nil {
						z.EncExtension(x.AnonInTestStrucIntf.T, yyxt157)
					} else if z.EncBinary() {
						z.EncBinaryMarshal(x.AnonInTestStrucIntf.T)
					} else if !z.EncBinary() && z.IsJSONHandle() {
						z.EncJSONMarshal(x.AnonInTestStrucIntf.T)
					} else {
						z.EncFallback(x.AnonInTestStrucIntf.T)
					}
				} else {
					r.EncodeNil()
				}
			}
			if yyn75 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyq2[72] {
					yy158 := *x.AnonInTestStrucIntf.Tptr
					if !z.EncBasicHandle().TimeNotBuiltin {
						r.EncodeTime(yy158)
					} else if yyxt159 := z.Extension(z.I2Rtid(yy158)); yyxt159 != nil {
						z.EncExtension(yy158, yyxt159)
					} else if z.EncBinary() {
						z.EncBinaryMarshal(yy158)
					} else if !z.EncBinary() && z.IsJSONHandle() {
						z.EncJSONMarshal(yy158)
					} else {
						z.EncFallback(yy158)
					}
				} else {
					r.EncodeNil()
				}
			}
			z.EncWriteArrayElem()
			if yyq2[73] {
				h.encMapstringPtrtoTestStrucFlex((map[string]*TestStrucFlex)(x.Mtsptr), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[74] {
				h.encMapstringTestStrucFlex((map[string]TestStrucFlex)(x.Mts), e)
			} else {
				r.EncodeNil()
			}
			z.EncWriteArrayElem()
			if yyq2[75] {
				h.encSlicePtrtoTestStrucFlex(([]*TestStrucFlex)(x.Its), e)
			} else {
				r.EncodeNil()
			}
			if yyn79 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyq2[76] {
					x.Nteststruc.CodecEncodeSelf(e)
				} else {
					r.EncodeNil()
				}
			}
			z.EncWriteArrayEnd()
		} else {
			var yynn2 int
			for _, b := range yyq2 {
				if b {
					yynn2++
				}
			}
			z.EncWriteMapStart(yynn2)
			yynn2 = 0
			if yyq2[0] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"S\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `S`)
				}
				z.EncWriteMapElemValue()
				if z.EncBasicHandle().StringToRaw {
					r.EncodeStringBytesRaw(z.BytesView(string(x.TestStrucCommon.S)))
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, string(x.TestStrucCommon.S))
				}
			}
			if yyq2[1] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I64`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.I64))
			}
			if yyq2[2] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I32\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I32`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.I32))
			}
			if yyq2[3] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I16\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I16`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.I16))
			}
			if yyq2[4] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I8\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I8`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.I8))
			}
			if yyq2[5] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I64n\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I64n`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.I64n))
			}
			if yyq2[6] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I32n\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I32n`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.I32n))
			}
			if yyq2[7] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I16n\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I16n`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.I16n))
			}
			if yyq2[8] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I8n\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I8n`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.I8n))
			}
			if yyq2[9] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ui64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64`)
				}
				z.EncWriteMapElemValue()
				r.EncodeUint(uint64(x.TestStrucCommon.Ui64))
			}
			if yyq2[10] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ui32\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ui32`)
				}
				z.EncWriteMapElemValue()
				r.EncodeUint(uint64(x.TestStrucCommon.Ui32))
			}
			if yyq2[11] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ui16\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ui16`)
				}
				z.EncWriteMapElemValue()
				r.EncodeUint(uint64(x.TestStrucCommon.Ui16))
			}
			if yyq2[12] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ui8\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ui8`)
				}
				z.EncWriteMapElemValue()
				r.EncodeUint(uint64(x.TestStrucCommon.Ui8))
			}
			if yyq2[13] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"F64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `F64`)
				}
				z.EncWriteMapElemValue()
				r.EncodeFloat64(float64(x.TestStrucCommon.F64))
			}
			if yyq2[14] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"F32\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `F32`)
				}
				z.EncWriteMapElemValue()
				r.EncodeFloat32(float32(x.TestStrucCommon.F32))
			}
			if yyq2[15] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"B\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `B`)
				}
				z.EncWriteMapElemValue()
				r.EncodeBool(bool(x.TestStrucCommon.B))
			}
			if yyq2[16] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"By\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `By`)
				}
				z.EncWriteMapElemValue()
				r.EncodeUint(uint64(x.TestStrucCommon.By))
			}
			if yyq2[17] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Sslice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Sslice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceStringV(x.TestStrucCommon.Sslice, e)
			}
			if yyq2[18] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I64slice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I64slice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceInt64V(x.TestStrucCommon.I64slice, e)
			}
			if yyq2[19] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"I16slice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `I16slice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceInt16V(x.TestStrucCommon.I16slice, e)
			}
			if yyq2[20] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ui64slice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64slice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceUint64V(x.TestStrucCommon.Ui64slice, e)
			}
			if yyq2[21] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ui8slice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ui8slice`)
				}
				z.EncWriteMapElemValue()
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Ui8slice))
			}
			if yyq2[22] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Bslice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Bslice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceBoolV(x.TestStrucCommon.Bslice, e)
			}
			if yyq2[23] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Byslice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Byslice`)
				}
				z.EncWriteMapElemValue()
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Byslice))
			}
			if yyq2[24] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"BytesSlice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `BytesSlice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceBytesV(x.TestStrucCommon.BytesSlice, e)
			}
			if yyq2[25] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Iptrslice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Iptrslice`)
				}
				z.EncWriteMapElemValue()
				h.encSlicePtrtoint64(([]*int64)(x.TestStrucCommon.Iptrslice), e)
			}
			if yyq2[26] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"WrapSliceInt64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `WrapSliceInt64`)
				}
				z.EncWriteMapElemValue()
				x.TestStrucCommon.WrapSliceInt64.CodecEncodeSelf(e)
			}
			if yyq2[27] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"WrapSliceString\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `WrapSliceString`)
				}
				z.EncWriteMapElemValue()
				x.TestStrucCommon.WrapSliceString.CodecEncodeSelf(e)
			}
			if yyq2[28] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Msi64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Msi64`)
				}
				z.EncWriteMapElemValue()
				z.F.EncMapStringInt64V(x.TestStrucCommon.Msi64, e)
			}
			if yyq2[29] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Msbytes\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Msbytes`)
				}
				z.EncWriteMapElemValue()
				z.F.EncMapStringBytesV(x.TestStrucCommon.Msbytes, e)
			}
			if yyq2[30] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Simplef\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Simplef`)
				}
				z.EncWriteMapElemValue()
				yy194 := &x.TestStrucCommon.Simplef
				yy194.CodecEncodeSelf(e)
			}
			if yyq2[31] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"SstrUi64T\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `SstrUi64T`)
				}
				z.EncWriteMapElemValue()
				h.encSlicestringUint64T(([]stringUint64T)(x.TestStrucCommon.SstrUi64T), e)
			}
			if yyq2[32] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"MstrUi64T\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `MstrUi64T`)
				}
				z.EncWriteMapElemValue()
				h.encMapstringPtrtostringUint64T((map[string]*stringUint64T)(x.TestStrucCommon.MstrUi64T), e)
			}
			if yyq2[33] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AS\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AS`)
				}
				z.EncWriteMapElemValue()
				if z.EncBasicHandle().StringToRaw {
					r.EncodeStringBytesRaw(z.BytesView(string(x.TestStrucCommon.AnonInTestStruc.AS)))
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, string(x.TestStrucCommon.AnonInTestStruc.AS))
				}
			}
			if yyq2[34] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AI64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AI64`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI64))
			}
			if yyq2[35] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AI16\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AI16`)
				}
				z.EncWriteMapElemValue()
				r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI16))
			}
			if yyq2[36] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AUi64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64`)
				}
				z.EncWriteMapElemValue()
				r.EncodeUint(uint64(x.TestStrucCommon.AnonInTestStruc.AUi64))
			}
			if yyq2[37] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"ASslice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `ASslice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceStringV(x.TestStrucCommon.AnonInTestStruc.ASslice, e)
			}
			if yyq2[38] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AI64slice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AI64slice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice, e)
			}
			if yyq2[39] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AUi64slice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64slice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64slice, e)
			}
			if yyq2[40] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AF64slice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AF64slice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceFloat64V(x.TestStrucCommon.AnonInTestStruc.AF64slice, e)
			}
			if yyq2[41] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AF32slice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AF32slice`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceFloat32V(x.TestStrucCommon.AnonInTestStruc.AF32slice, e)
			}
			if yyq2[42] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AMSU16\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16`)
				}
				z.EncWriteMapElemValue()
				h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16), e)
			}
			if yyq2[43] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AI64arr0\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AI64arr0`)
				}
				z.EncWriteMapElemValue()
				yy208 := &x.TestStrucCommon.AnonInTestStruc.AI64arr0
				h.encArray0int64((*[0]int64)(yy208), e)
			}
			if yyq2[44] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AI64slice0\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AI64slice0`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice0, e)
			}
			if yyq2[45] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AUi64sliceN\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AUi64sliceN`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, e)
			}
			if yyq2[46] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AMSU16N\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16N`)
				}
				z.EncWriteMapElemValue()
				h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16N), e)
			}
			if yyq2[47] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"AMSU16E\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `AMSU16E`)
				}
				z.EncWriteMapElemValue()
				h.encMapstringuint16((map[string]uint16)(x.TestStrucCommon.AnonInTestStruc.AMSU16E), e)
			}
			if yyq2[48] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"NotAnon\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `NotAnon`)
				}
				z.EncWriteMapElemValue()
				yy214 := &x.TestStrucCommon.NotAnon
				yy214.CodecEncodeSelf(e)
			}
			if yyq2[49] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Nmap\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Nmap`)
				}
				z.EncWriteMapElemValue()
				z.F.EncMapStringBoolV(x.TestStrucCommon.Nmap, e)
			}
			if yyq2[50] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Nslice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Nslice`)
				}
				z.EncWriteMapElemValue()
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Nslice))
			}
			if yyq2[51] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Nint64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Nint64`)
				}
				z.EncWriteMapElemValue()
				if yyn54 {
					r.EncodeNil()
				} else {
					yy218 := *x.TestStrucCommon.Nint64
					r.EncodeInt(int64(yy218))
				}
			}
			if yyq2[52] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Chstr\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Chstr`)
				}
				z.EncWriteMapElemValue()
				h.encChanstring((chan string)(x.Chstr), e)
			}
			if yyq2[53] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Mis\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Mis`)
				}
				z.EncWriteMapElemValue()
				z.F.EncMapIntStringV(x.Mis, e)
			}
			if yyq2[54] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Mbu64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Mbu64`)
				}
				z.EncWriteMapElemValue()
				h.encMapboolc3RydWN0IHt9((map[bool]struct{})(x.Mbu64), e)
			}
			if yyq2[55] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Miwu64s\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Miwu64s`)
				}
				z.EncWriteMapElemValue()
				h.encMapintwrapUint64Slice((map[int]wrapUint64Slice)(x.Miwu64s), e)
			}
			if yyq2[56] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Mfwss\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Mfwss`)
				}
				z.EncWriteMapElemValue()
				h.encMapfloat64wrapStringSlice((map[float64]wrapStringSlice)(x.Mfwss), e)
			}
			if yyq2[57] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Mf32wss\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Mf32wss`)
				}
				z.EncWriteMapElemValue()
				h.encMapfloat32wrapStringSlice((map[float32]wrapStringSlice)(x.Mf32wss), e)
			}
			if yyq2[58] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Mui2wss\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Mui2wss`)
				}
				z.EncWriteMapElemValue()
				h.encMapuint64wrapStringSlice((map[uint64]wrapStringSlice)(x.Mui2wss), e)
			}
			if yyq2[59] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Msu2wss\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Msu2wss`)
				}
				z.EncWriteMapElemValue()
				h.encMapstringUint64TwrapStringSlice((map[stringUint64T]wrapStringSlice)(x.Msu2wss), e)
			}
			if yyq2[60] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ci64\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ci64`)
				}
				z.EncWriteMapElemValue()
				x.Ci64.CodecEncodeSelf(e)
			}
			if yyq2[61] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Swrapbytes\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Swrapbytes`)
				}
				z.EncWriteMapElemValue()
				h.encSlicewrapBytes(([]wrapBytes)(x.Swrapbytes), e)
			}
			if yyq2[62] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Swrapuint8\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Swrapuint8`)
				}
				z.EncWriteMapElemValue()
				h.encSlicewrapUint8(([]wrapUint8)(x.Swrapuint8), e)
			}
			if yyq2[63] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"ArrStrUi64T\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `ArrStrUi64T`)
				}
				z.EncWriteMapElemValue()
				yy231 := &x.ArrStrUi64T
				h.encArray4stringUint64T((*[4]stringUint64T)(yy231), e)
			}
			if yyq2[64] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ui64array\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64array`)
				}
				z.EncWriteMapElemValue()
				yy233 := &x.Ui64array
				h.encArray4uint64((*[4]uint64)(yy233), e)
			}
			if yyq2[65] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ui64slicearray\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ui64slicearray`)
				}
				z.EncWriteMapElemValue()
				h.encSlicePtrtoArray4uint64(([]*[4]uint64)(x.Ui64slicearray), e)
			}
			if yyq2[66] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"SintfAarray\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `SintfAarray`)
				}
				z.EncWriteMapElemValue()
				z.F.EncSliceIntfV(x.SintfAarray, e)
			}
			if yyq2[67] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"MstrUi64TSelf\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `MstrUi64TSelf`)
				}
				z.EncWriteMapElemValue()
				h.encMapstringUint64TPtrtostringUint64T((map[stringUint64T]*stringUint64T)(x.MstrUi64TSelf), e)
			}
			if yyq2[68] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Islice\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Islice`)
				}
				z.EncWriteMapElemValue()
				if yyn71 {
					r.EncodeNil()
				} else {
					z.F.EncSliceIntfV(x.AnonInTestStrucIntf.Islice, e)
				}
			}
			if yyq2[69] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Ms\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Ms`)
				}
				z.EncWriteMapElemValue()
				if yyn72 {
					r.EncodeNil()
				} else {
					z.F.EncMapStringIntfV(x.AnonInTestStrucIntf.Ms, e)
				}
			}
			if yyq2[70] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Nintf\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Nintf`)
				}
				z.EncWriteMapElemValue()
				if yyn73 {
					r.EncodeNil()
				} else {
					z.EncFallback(x.AnonInTestStrucIntf.Nintf)
				}
			}
			if yyq2[71] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"T\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `T`)
				}
				z.EncWriteMapElemValue()
				if yyn74 {
					r.EncodeNil()
				} else {
					if !z.EncBasicHandle().TimeNotBuiltin {
						r.EncodeTime(x.AnonInTestStrucIntf.T)
					} else if yyxt241 := z.Extension(z.I2Rtid(x.AnonInTestStrucIntf.T)); yyxt241 != nil {
						z.EncExtension(x.AnonInTestStrucIntf.T, yyxt241)
					} else if z.EncBinary() {
						z.EncBinaryMarshal(x.AnonInTestStrucIntf.T)
					} else if !z.EncBinary() && z.IsJSONHandle() {
						z.EncJSONMarshal(x.AnonInTestStrucIntf.T)
					} else {
						z.EncFallback(x.AnonInTestStrucIntf.T)
					}
				}
			}
			if yyq2[72] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Tptr\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Tptr`)
				}
				z.EncWriteMapElemValue()
				if yyn75 {
					r.EncodeNil()
				} else {
					yy242 := *x.AnonInTestStrucIntf.Tptr
					if !z.EncBasicHandle().TimeNotBuiltin {
						r.EncodeTime(yy242)
					} else if yyxt243 := z.Extension(z.I2Rtid(yy242)); yyxt243 != nil {
						z.EncExtension(yy242, yyxt243)
					} else if z.EncBinary() {
						z.EncBinaryMarshal(yy242)
					} else if !z.EncBinary() && z.IsJSONHandle() {
						z.EncJSONMarshal(yy242)
					} else {
						z.EncFallback(yy242)
					}
				}
			}
			if yyq2[73] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Mtsptr\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Mtsptr`)
				}
				z.EncWriteMapElemValue()
				h.encMapstringPtrtoTestStrucFlex((map[string]*TestStrucFlex)(x.Mtsptr), e)
			}
			if yyq2[74] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Mts\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Mts`)
				}
				z.EncWriteMapElemValue()
				h.encMapstringTestStrucFlex((map[string]TestStrucFlex)(x.Mts), e)
			}
			if yyq2[75] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Its\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Its`)
				}
				z.EncWriteMapElemValue()
				h.encSlicePtrtoTestStrucFlex(([]*TestStrucFlex)(x.Its), e)
			}
			if yyq2[76] {
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"Nteststruc\"")
				} else {
					r.EncodeStringEnc(codecSelferCcUTF819780, `Nteststruc`)
				}
				z.EncWriteMapElemValue()
				if yyn79 {
					r.EncodeNil()
				} else {
					x.Nteststruc.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestStrucFlex) CodecDecodeSelf(d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeMap19780 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
			z.DecReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
	} else if yyct2 == codecSelferValueTypeArray19780 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 == 0 {
			z.DecReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct19780)
	}
}

func (x *TestStrucFlex) codecDecodeSelfFromMap(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "S":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.S = ""
			} else {
				x.TestStrucCommon.S = (string)(string(r.DecodeStringAsBytes()))
			}
		case "I64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I64 = 0
			} else {
				x.TestStrucCommon.I64 = (int64)(r.DecodeInt64())
			}
		case "I32":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I32 = 0
			} else {
				x.TestStrucCommon.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
			}
		case "I16":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I16 = 0
			} else {
				x.TestStrucCommon.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "I8":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I8 = 0
			} else {
				x.TestStrucCommon.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
			}
		case "I64n":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I64n = 0
			} else {
				x.TestStrucCommon.I64n = (int64)(r.DecodeInt64())
			}
		case "I32n":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I32n = 0
			} else {
				x.TestStrucCommon.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
			}
		case "I16n":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I16n = 0
			} else {
				x.TestStrucCommon.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "I8n":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I8n = 0
			} else {
				x.TestStrucCommon.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
			}
		case "Ui64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui64 = 0
			} else {
				x.TestStrucCommon.Ui64 = (uint64)(r.DecodeUint64())
			}
		case "Ui32":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui32 = 0
			} else {
				x.TestStrucCommon.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
			}
		case "Ui16":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui16 = 0
			} else {
				x.TestStrucCommon.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
			}
		case "Ui8":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui8 = 0
			} else {
				x.TestStrucCommon.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		case "F64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.F64 = 0
			} else {
				x.TestStrucCommon.F64 = (float64)(r.DecodeFloat64())
			}
		case "F32":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.F32 = 0
			} else {
				x.TestStrucCommon.F32 = (float32)(z.DecDecodeFloat32())
			}
		case "B":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.B = false
			} else {
				x.TestStrucCommon.B = (bool)(r.DecodeBool())
			}
		case "By":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.By = 0
			} else {
				x.TestStrucCommon.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
			}
		case "Sslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Sslice = nil
			} else {
				z.F.DecSliceStringX(&x.TestStrucCommon.Sslice, d)
			}
		case "I64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I64slice = nil
			} else {
				z.F.DecSliceInt64X(&x.TestStrucCommon.I64slice, d)
			}
		case "I16slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.I16slice = nil
			} else {
				z.F.DecSliceInt16X(&x.TestStrucCommon.I16slice, d)
			}
		case "Ui64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui64slice = nil
			} else {
				z.F.DecSliceUint64X(&x.TestStrucCommon.Ui64slice, d)
			}
		case "Ui8slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Ui8slice = nil
			} else {
				x.TestStrucCommon.Ui8slice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Ui8slice), false)
			}
		case "Bslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Bslice = nil
			} else {
				z.F.DecSliceBoolX(&x.TestStrucCommon.Bslice, d)
			}
		case "Byslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Byslice = nil
			} else {
				x.TestStrucCommon.Byslice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Byslice), false)
			}
		case "BytesSlice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.BytesSlice = nil
			} else {
				z.F.DecSliceBytesX(&x.TestStrucCommon.BytesSlice, d)
			}
		case "Iptrslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Iptrslice = nil
			} else {
				h.decSlicePtrtoint64((*[]*int64)(&x.TestStrucCommon.Iptrslice), d)
			}
		case "WrapSliceInt64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.WrapSliceInt64 = nil
			} else {
				x.TestStrucCommon.WrapSliceInt64.CodecDecodeSelf(d)
			}
		case "WrapSliceString":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.WrapSliceString = nil
			} else {
				x.TestStrucCommon.WrapSliceString.CodecDecodeSelf(d)
			}
		case "Msi64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Msi64 = nil
			} else {
				z.F.DecMapStringInt64X(&x.TestStrucCommon.Msi64, d)
			}
		case "Msbytes":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Msbytes = nil
			} else {
				z.F.DecMapStringBytesX(&x.TestStrucCommon.Msbytes, d)
			}
		case "Simplef":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Simplef = testSimpleFields{}
			} else {
				x.TestStrucCommon.Simplef.CodecDecodeSelf(d)
			}
		case "SstrUi64T":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.SstrUi64T = nil
			} else {
				h.decSlicestringUint64T((*[]stringUint64T)(&x.TestStrucCommon.SstrUi64T), d)
			}
		case "MstrUi64T":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.MstrUi64T = nil
			} else {
				h.decMapstringPtrtostringUint64T((*map[string]*stringUint64T)(&x.TestStrucCommon.MstrUi64T), d)
			}
		case "AS":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AS = ""
			} else {
				x.TestStrucCommon.AnonInTestStruc.AS = (string)(string(r.DecodeStringAsBytes()))
			}
		case "AI64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI64 = 0
			} else {
				x.TestStrucCommon.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
			}
		case "AI16":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI16 = 0
			} else {
				x.TestStrucCommon.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "AUi64":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AUi64 = 0
			} else {
				x.TestStrucCommon.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
			}
		case "ASslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.ASslice = nil
			} else {
				z.F.DecSliceStringX(&x.TestStrucCommon.AnonInTestStruc.ASslice, d)
			}
		case "AI64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI64slice = nil
			} else {
				z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice, d)
			}
		case "AUi64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AUi64slice = nil
			} else {
				z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64slice, d)
			}
		case "AF64slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AF64slice = nil
			} else {
				z.F.DecSliceFloat64X(&x.TestStrucCommon.AnonInTestStruc.AF64slice, d)
			}
		case "AF32slice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AF32slice = nil
			} else {
				z.F.DecSliceFloat32X(&x.TestStrucCommon.AnonInTestStruc.AF32slice, d)
			}
		case "AMSU16":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AMSU16 = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16), d)
			}
		case "AI64arr0":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI64arr0 = [0]int64{}
			} else {
				h.decArray0int64((*[0]int64)(&x.TestStrucCommon.AnonInTestStruc.AI64arr0), d)
			}
		case "AI64slice0":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AI64slice0 = nil
			} else {
				z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice0, d)
			}
		case "AUi64sliceN":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AUi64sliceN = nil
			} else {
				z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, d)
			}
		case "AMSU16N":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AMSU16N = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16N), d)
			}
		case "AMSU16E":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.AnonInTestStruc.AMSU16E = nil
			} else {
				h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16E), d)
			}
		case "NotAnon":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.NotAnon = AnonInTestStruc{}
			} else {
				x.TestStrucCommon.NotAnon.CodecDecodeSelf(d)
			}
		case "Nmap":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Nmap = nil
			} else {
				z.F.DecMapStringBoolX(&x.TestStrucCommon.Nmap, d)
			}
		case "Nslice":
			if r.TryDecodeAsNil() {
				x.TestStrucCommon.Nslice = nil
			} else {
				x.TestStrucCommon.Nslice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Nslice), false)
			}
		case "Nint64":
			if r.TryDecodeAsNil() {
				if x.TestStrucCommon.Nint64 != nil { // remove the if-true
					x.TestStrucCommon.Nint64 = nil
				}
			} else {
				if x.TestStrucCommon.Nint64 == nil {
					x.TestStrucCommon.Nint64 = new(int64)
				}

				*x.TestStrucCommon.Nint64 = (int64)(r.DecodeInt64())
			}
		case "Chstr":
			if r.TryDecodeAsNil() {
				x.Chstr = nil
			} else {
				h.decChanstring((*chan string)(&x.Chstr), d)
			}
		case "Mis":
			if r.TryDecodeAsNil() {
				x.Mis = nil
			} else {
				z.F.DecMapIntStringX(&x.Mis, d)
			}
		case "Mbu64":
			if r.TryDecodeAsNil() {
				x.Mbu64 = nil
			} else {
				h.decMapboolc3RydWN0IHt9((*map[bool]struct{})(&x.Mbu64), d)
			}
		case "Miwu64s":
			if r.TryDecodeAsNil() {
				x.Miwu64s = nil
			} else {
				h.decMapintwrapUint64Slice((*map[int]wrapUint64Slice)(&x.Miwu64s), d)
			}
		case "Mfwss":
			if r.TryDecodeAsNil() {
				x.Mfwss = nil
			} else {
				h.decMapfloat64wrapStringSlice((*map[float64]wrapStringSlice)(&x.Mfwss), d)
			}
		case "Mf32wss":
			if r.TryDecodeAsNil() {
				x.Mf32wss = nil
			} else {
				h.decMapfloat32wrapStringSlice((*map[float32]wrapStringSlice)(&x.Mf32wss), d)
			}
		case "Mui2wss":
			if r.TryDecodeAsNil() {
				x.Mui2wss = nil
			} else {
				h.decMapuint64wrapStringSlice((*map[uint64]wrapStringSlice)(&x.Mui2wss), d)
			}
		case "Msu2wss":
			if r.TryDecodeAsNil() {
				x.Msu2wss = nil
			} else {
				h.decMapstringUint64TwrapStringSlice((*map[stringUint64T]wrapStringSlice)(&x.Msu2wss), d)
			}
		case "Ci64":
			if r.TryDecodeAsNil() {
				x.Ci64 = 0
			} else {
				x.Ci64.CodecDecodeSelf(d)
			}
		case "Swrapbytes":
			if r.TryDecodeAsNil() {
				x.Swrapbytes = nil
			} else {
				h.decSlicewrapBytes((*[]wrapBytes)(&x.Swrapbytes), d)
			}
		case "Swrapuint8":
			if r.TryDecodeAsNil() {
				x.Swrapuint8 = nil
			} else {
				h.decSlicewrapUint8((*[]wrapUint8)(&x.Swrapuint8), d)
			}
		case "ArrStrUi64T":
			if r.TryDecodeAsNil() {
				x.ArrStrUi64T = [4]stringUint64T{}
			} else {
				h.decArray4stringUint64T((*[4]stringUint64T)(&x.ArrStrUi64T), d)
			}
		case "Ui64array":
			if r.TryDecodeAsNil() {
				x.Ui64array = [4]uint64{}
			} else {
				h.decArray4uint64((*[4]uint64)(&x.Ui64array), d)
			}
		case "Ui64slicearray":
			if r.TryDecodeAsNil() {
				x.Ui64slicearray = nil
			} else {
				h.decSlicePtrtoArray4uint64((*[]*[4]uint64)(&x.Ui64slicearray), d)
			}
		case "SintfAarray":
			if r.TryDecodeAsNil() {
				x.SintfAarray = nil
			} else {
				z.F.DecSliceIntfX(&x.SintfAarray, d)
			}
		case "MstrUi64TSelf":
			if r.TryDecodeAsNil() {
				x.MstrUi64TSelf = nil
			} else {
				h.decMapstringUint64TPtrtostringUint64T((*map[stringUint64T]*stringUint64T)(&x.MstrUi64TSelf), d)
			}
		case "Islice":
			if r.TryDecodeAsNil() {
				if x.AnonInTestStrucIntf != nil { // remove the if-true
					x.AnonInTestStrucIntf.Islice = nil
				}
			} else {
				if x.AnonInTestStrucIntf == nil {
					x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
				}

				z.F.DecSliceIntfX(&x.AnonInTestStrucIntf.Islice, d)
			}
		case "Ms":
			if r.TryDecodeAsNil() {
				if x.AnonInTestStrucIntf != nil { // remove the if-true
					x.AnonInTestStrucIntf.Ms = nil
				}
			} else {
				if x.AnonInTestStrucIntf == nil {
					x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
				}

				z.F.DecMapStringIntfX(&x.AnonInTestStrucIntf.Ms, d)
			}
		case "Nintf":
			if r.TryDecodeAsNil() {
				if x.AnonInTestStrucIntf != nil { // remove the if-true
					x.AnonInTestStrucIntf.Nintf = nil
				}
			} else {
				if x.AnonInTestStrucIntf == nil {
					x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
				}

				z.DecFallback(&x.AnonInTestStrucIntf.Nintf, true)
			}
		case "T":
			if r.TryDecodeAsNil() {
				if x.AnonInTestStrucIntf != nil { // remove the if-true
					x.AnonInTestStrucIntf.T = time.Time{}
				}
			} else {
				if x.AnonInTestStrucIntf == nil {
					x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
				}

				if !z.DecBasicHandle().TimeNotBuiltin {
					x.AnonInTestStrucIntf.T = r.DecodeTime()
				} else if yyxt121 := z.Extension(z.I2Rtid(x.AnonInTestStrucIntf.T)); yyxt121 != nil {
					z.DecExtension(x.AnonInTestStrucIntf.T, yyxt121)
				} else if z.DecBinary() {
					z.DecBinaryUnmarshal(&x.AnonInTestStrucIntf.T)
				} else if !z.DecBinary() && z.IsJSONHandle() {
					z.DecJSONUnmarshal(&x.AnonInTestStrucIntf.T)
				} else {
					z.DecFallback(&x.AnonInTestStrucIntf.T, false)
				}
			}
		case "Tptr":
			if r.TryDecodeAsNil() {
				if x.AnonInTestStrucIntf != nil && x.AnonInTestStrucIntf.Tptr != nil { // remove the if-true
					x.AnonInTestStrucIntf.Tptr = nil
				}
			} else {
				if x.AnonInTestStrucIntf == nil {
					x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
				}
				if x.AnonInTestStrucIntf.Tptr == nil {
					x.AnonInTestStrucIntf.Tptr = new(time.Time)
				}

				if !z.DecBasicHandle().TimeNotBuiltin {
					*x.AnonInTestStrucIntf.Tptr = r.DecodeTime()
				} else if yyxt123 := z.Extension(z.I2Rtid(x.AnonInTestStrucIntf.Tptr)); yyxt123 != nil {
					z.DecExtension(x.AnonInTestStrucIntf.Tptr, yyxt123)
				} else if z.DecBinary() {
					z.DecBinaryUnmarshal(x.AnonInTestStrucIntf.Tptr)
				} else if !z.DecBinary() && z.IsJSONHandle() {
					z.DecJSONUnmarshal(x.AnonInTestStrucIntf.Tptr)
				} else {
					z.DecFallback(x.AnonInTestStrucIntf.Tptr, false)
				}
			}
		case "Mtsptr":
			if r.TryDecodeAsNil() {
				x.Mtsptr = nil
			} else {
				h.decMapstringPtrtoTestStrucFlex((*map[string]*TestStrucFlex)(&x.Mtsptr), d)
			}
		case "Mts":
			if r.TryDecodeAsNil() {
				x.Mts = nil
			} else {
				h.decMapstringTestStrucFlex((*map[string]TestStrucFlex)(&x.Mts), d)
			}
		case "Its":
			if r.TryDecodeAsNil() {
				x.Its = nil
			} else {
				h.decSlicePtrtoTestStrucFlex((*[]*TestStrucFlex)(&x.Its), d)
			}
		case "Nteststruc":
			if r.TryDecodeAsNil() {
				if x.Nteststruc != nil { // remove the if-true
					x.Nteststruc = nil
				}
			} else {
				if x.Nteststruc == nil {
					x.Nteststruc = new(TestStrucFlex)
				}

				x.Nteststruc.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
	z.DecReadMapEnd()
}

func (x *TestStrucFlex) codecDecodeSelfFromArray(l int, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj131 int
	var yyb131 bool
	var yyhl131 bool = l >= 0
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.S = ""
	} else {
		x.TestStrucCommon.S = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I64 = 0
	} else {
		x.TestStrucCommon.I64 = (int64)(r.DecodeInt64())
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I32 = 0
	} else {
		x.TestStrucCommon.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I16 = 0
	} else {
		x.TestStrucCommon.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I8 = 0
	} else {
		x.TestStrucCommon.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I64n = 0
	} else {
		x.TestStrucCommon.I64n = (int64)(r.DecodeInt64())
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I32n = 0
	} else {
		x.TestStrucCommon.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I16n = 0
	} else {
		x.TestStrucCommon.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I8n = 0
	} else {
		x.TestStrucCommon.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui64 = 0
	} else {
		x.TestStrucCommon.Ui64 = (uint64)(r.DecodeUint64())
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui32 = 0
	} else {
		x.TestStrucCommon.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui16 = 0
	} else {
		x.TestStrucCommon.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui8 = 0
	} else {
		x.TestStrucCommon.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.F64 = 0
	} else {
		x.TestStrucCommon.F64 = (float64)(r.DecodeFloat64())
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.F32 = 0
	} else {
		x.TestStrucCommon.F32 = (float32)(z.DecDecodeFloat32())
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.B = false
	} else {
		x.TestStrucCommon.B = (bool)(r.DecodeBool())
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.By = 0
	} else {
		x.TestStrucCommon.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Sslice = nil
	} else {
		z.F.DecSliceStringX(&x.TestStrucCommon.Sslice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I64slice = nil
	} else {
		z.F.DecSliceInt64X(&x.TestStrucCommon.I64slice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.I16slice = nil
	} else {
		z.F.DecSliceInt16X(&x.TestStrucCommon.I16slice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui64slice = nil
	} else {
		z.F.DecSliceUint64X(&x.TestStrucCommon.Ui64slice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Ui8slice = nil
	} else {
		x.TestStrucCommon.Ui8slice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Ui8slice), false)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Bslice = nil
	} else {
		z.F.DecSliceBoolX(&x.TestStrucCommon.Bslice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Byslice = nil
	} else {
		x.TestStrucCommon.Byslice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Byslice), false)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.BytesSlice = nil
	} else {
		z.F.DecSliceBytesX(&x.TestStrucCommon.BytesSlice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Iptrslice = nil
	} else {
		h.decSlicePtrtoint64((*[]*int64)(&x.TestStrucCommon.Iptrslice), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.WrapSliceInt64 = nil
	} else {
		x.TestStrucCommon.WrapSliceInt64.CodecDecodeSelf(d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.WrapSliceString = nil
	} else {
		x.TestStrucCommon.WrapSliceString.CodecDecodeSelf(d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Msi64 = nil
	} else {
		z.F.DecMapStringInt64X(&x.TestStrucCommon.Msi64, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Msbytes = nil
	} else {
		z.F.DecMapStringBytesX(&x.TestStrucCommon.Msbytes, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Simplef = testSimpleFields{}
	} else {
		x.TestStrucCommon.Simplef.CodecDecodeSelf(d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.SstrUi64T = nil
	} else {
		h.decSlicestringUint64T((*[]stringUint64T)(&x.TestStrucCommon.SstrUi64T), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.MstrUi64T = nil
	} else {
		h.decMapstringPtrtostringUint64T((*map[string]*stringUint64T)(&x.TestStrucCommon.MstrUi64T), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AS = ""
	} else {
		x.TestStrucCommon.AnonInTestStruc.AS = (string)(string(r.DecodeStringAsBytes()))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI64 = 0
	} else {
		x.TestStrucCommon.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI16 = 0
	} else {
		x.TestStrucCommon.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AUi64 = 0
	} else {
		x.TestStrucCommon.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.ASslice = nil
	} else {
		z.F.DecSliceStringX(&x.TestStrucCommon.AnonInTestStruc.ASslice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI64slice = nil
	} else {
		z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AUi64slice = nil
	} else {
		z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64slice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AF64slice = nil
	} else {
		z.F.DecSliceFloat64X(&x.TestStrucCommon.AnonInTestStruc.AF64slice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AF32slice = nil
	} else {
		z.F.DecSliceFloat32X(&x.TestStrucCommon.AnonInTestStruc.AF32slice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AMSU16 = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI64arr0 = [0]int64{}
	} else {
		h.decArray0int64((*[0]int64)(&x.TestStrucCommon.AnonInTestStruc.AI64arr0), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AI64slice0 = nil
	} else {
		z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice0, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AUi64sliceN = nil
	} else {
		z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AMSU16N = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16N), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.AnonInTestStruc.AMSU16E = nil
	} else {
		h.decMapstringuint16((*map[string]uint16)(&x.TestStrucCommon.AnonInTestStruc.AMSU16E), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.NotAnon = AnonInTestStruc{}
	} else {
		x.TestStrucCommon.NotAnon.CodecDecodeSelf(d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Nmap = nil
	} else {
		z.F.DecMapStringBoolX(&x.TestStrucCommon.Nmap, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.TestStrucCommon.Nslice = nil
	} else {
		x.TestStrucCommon.Nslice = r.DecodeBytes(([]byte)(x.TestStrucCommon.Nslice), false)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.TestStrucCommon.Nint64 != nil { // remove the if-true
			x.TestStrucCommon.Nint64 = nil
		}
	} else {
		if x.TestStrucCommon.Nint64 == nil {
			x.TestStrucCommon.Nint64 = new(int64)
		}

		*x.TestStrucCommon.Nint64 = (int64)(r.DecodeInt64())
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Chstr = nil
	} else {
		h.decChanstring((*chan string)(&x.Chstr), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Mis = nil
	} else {
		z.F.DecMapIntStringX(&x.Mis, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Mbu64 = nil
	} else {
		h.decMapboolc3RydWN0IHt9((*map[bool]struct{})(&x.Mbu64), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Miwu64s = nil
	} else {
		h.decMapintwrapUint64Slice((*map[int]wrapUint64Slice)(&x.Miwu64s), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Mfwss = nil
	} else {
		h.decMapfloat64wrapStringSlice((*map[float64]wrapStringSlice)(&x.Mfwss), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Mf32wss = nil
	} else {
		h.decMapfloat32wrapStringSlice((*map[float32]wrapStringSlice)(&x.Mf32wss), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Mui2wss = nil
	} else {
		h.decMapuint64wrapStringSlice((*map[uint64]wrapStringSlice)(&x.Mui2wss), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Msu2wss = nil
	} else {
		h.decMapstringUint64TwrapStringSlice((*map[stringUint64T]wrapStringSlice)(&x.Msu2wss), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ci64 = 0
	} else {
		x.Ci64.CodecDecodeSelf(d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Swrapbytes = nil
	} else {
		h.decSlicewrapBytes((*[]wrapBytes)(&x.Swrapbytes), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Swrapuint8 = nil
	} else {
		h.decSlicewrapUint8((*[]wrapUint8)(&x.Swrapuint8), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.ArrStrUi64T = [4]stringUint64T{}
	} else {
		h.decArray4stringUint64T((*[4]stringUint64T)(&x.ArrStrUi64T), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui64array = [4]uint64{}
	} else {
		h.decArray4uint64((*[4]uint64)(&x.Ui64array), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Ui64slicearray = nil
	} else {
		h.decSlicePtrtoArray4uint64((*[]*[4]uint64)(&x.Ui64slicearray), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.SintfAarray = nil
	} else {
		z.F.DecSliceIntfX(&x.SintfAarray, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.MstrUi64TSelf = nil
	} else {
		h.decMapstringUint64TPtrtostringUint64T((*map[stringUint64T]*stringUint64T)(&x.MstrUi64TSelf), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.AnonInTestStrucIntf != nil { // remove the if-true
			x.AnonInTestStrucIntf.Islice = nil
		}
	} else {
		if x.AnonInTestStrucIntf == nil {
			x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
		}

		z.F.DecSliceIntfX(&x.AnonInTestStrucIntf.Islice, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.AnonInTestStrucIntf != nil { // remove the if-true
			x.AnonInTestStrucIntf.Ms = nil
		}
	} else {
		if x.AnonInTestStrucIntf == nil {
			x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
		}

		z.F.DecMapStringIntfX(&x.AnonInTestStrucIntf.Ms, d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.AnonInTestStrucIntf != nil { // remove the if-true
			x.AnonInTestStrucIntf.Nintf = nil
		}
	} else {
		if x.AnonInTestStrucIntf == nil {
			x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
		}

		z.DecFallback(&x.AnonInTestStrucIntf.Nintf, true)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.AnonInTestStrucIntf != nil { // remove the if-true
			x.AnonInTestStrucIntf.T = time.Time{}
		}
	} else {
		if x.AnonInTestStrucIntf == nil {
			x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
		}

		if !z.DecBasicHandle().TimeNotBuiltin {
			x.AnonInTestStrucIntf.T = r.DecodeTime()
		} else if yyxt249 := z.Extension(z.I2Rtid(x.AnonInTestStrucIntf.T)); yyxt249 != nil {
			z.DecExtension(x.AnonInTestStrucIntf.T, yyxt249)
		} else if z.DecBinary() {
			z.DecBinaryUnmarshal(&x.AnonInTestStrucIntf.T)
		} else if !z.DecBinary() && z.IsJSONHandle() {
			z.DecJSONUnmarshal(&x.AnonInTestStrucIntf.T)
		} else {
			z.DecFallback(&x.AnonInTestStrucIntf.T, false)
		}
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.AnonInTestStrucIntf != nil && x.AnonInTestStrucIntf.Tptr != nil { // remove the if-true
			x.AnonInTestStrucIntf.Tptr = nil
		}
	} else {
		if x.AnonInTestStrucIntf == nil {
			x.AnonInTestStrucIntf = new(AnonInTestStrucIntf)
		}
		if x.AnonInTestStrucIntf.Tptr == nil {
			x.AnonInTestStrucIntf.Tptr = new(time.Time)
		}

		if !z.DecBasicHandle().TimeNotBuiltin {
			*x.AnonInTestStrucIntf.Tptr = r.DecodeTime()
		} else if yyxt251 := z.Extension(z.I2Rtid(x.AnonInTestStrucIntf.Tptr)); yyxt251 != nil {
			z.DecExtension(x.AnonInTestStrucIntf.Tptr, yyxt251)
		} else if z.DecBinary() {
			z.DecBinaryUnmarshal(x.AnonInTestStrucIntf.Tptr)
		} else if !z.DecBinary() && z.IsJSONHandle() {
			z.DecJSONUnmarshal(x.AnonInTestStrucIntf.Tptr)
		} else {
			z.DecFallback(x.AnonInTestStrucIntf.Tptr, false)
		}
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Mtsptr = nil
	} else {
		h.decMapstringPtrtoTestStrucFlex((*map[string]*TestStrucFlex)(&x.Mtsptr), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Mts = nil
	} else {
		h.decMapstringTestStrucFlex((*map[string]TestStrucFlex)(&x.Mts), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		x.Its = nil
	} else {
		h.decSlicePtrtoTestStrucFlex((*[]*TestStrucFlex)(&x.Its), d)
	}
	yyj131++
	if yyhl131 {
		yyb131 = yyj131 > l
	} else {
		yyb131 = r.CheckBreak()
	}
	if yyb131 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryDecodeAsNil() {
		if x.Nteststruc != nil { // remove the if-true
			x.Nteststruc = nil
		}
	} else {
		if x.Nteststruc == nil {
			x.Nteststruc = new(TestStrucFlex)
		}

		x.Nteststruc.CodecDecodeSelf(d)
	}
	for {
		yyj131++
		if yyhl131 {
			yyb131 = yyj131 > l
		} else {
			yyb131 = r.CheckBreak()
		}
		if yyb131 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj131-1, "")
	}
	z.DecReadArrayEnd()
}

func (x codecSelfer19780) encwrapSliceUint64(v wrapSliceUint64, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		r.EncodeUint(uint64(yyv1))
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decwrapSliceUint64(v *wrapSliceUint64, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []uint64{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]uint64, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]uint64, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, 0)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = 0
				} else {
					yyv1[yyj1] = (uint64)(r.DecodeUint64())
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]uint64, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encwrapSliceString(v wrapSliceString, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if z.EncBasicHandle().StringToRaw {
			r.EncodeStringBytesRaw(z.BytesView(string(yyv1)))
		} else {
			r.EncodeStringEnc(codecSelferCcUTF819780, string(yyv1))
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decwrapSliceString(v *wrapSliceString, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []string{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]string, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]string, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, "")
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = ""
				} else {
					yyv1[yyj1] = (string)(string(r.DecodeStringAsBytes()))
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]string, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encwrapUint64Slice(v wrapUint64Slice, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		yyv1.CodecEncodeSelf(e)
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decwrapUint64Slice(v *wrapUint64Slice, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []wrapUint64{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]wrapUint64, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]wrapUint64, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, 0)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = 0
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]wrapUint64, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encwrapStringSlice(v wrapStringSlice, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		yyv1.CodecEncodeSelf(e)
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decwrapStringSlice(v *wrapStringSlice, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []wrapString{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]wrapString, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]wrapString, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, "")
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = ""
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]wrapString, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encMapstringuint16(v map[string]uint16, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		if z.EncBasicHandle().StringToRaw {
			r.EncodeStringBytesRaw(z.BytesView(string(yyk1)))
		} else {
			r.EncodeStringEnc(codecSelferCcUTF819780, string(yyk1))
		}
		z.EncWriteMapElemValue()
		r.EncodeUint(uint64(yyv1))
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapstringuint16(v *map[string]uint16, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 18)
		yyv1 = make(map[string]uint16, yyrl1)
		*v = yyv1
	}
	var yymk1 string
	var yymv1 uint16
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = ""
			} else {
				yymk1 = (string)(string(r.DecodeStringAsBytes()))
			}
			if yymg1 {
				yymv1 = yyv1[yymk1]
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				yymv1 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = 0
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encArray0int64(v *[0]int64, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		r.EncodeInt(int64(yyv1))
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decArray0int64(v *[0]int64, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := v
	yyh1, yyl1 := z.DecSliceHelperStart()
	if yyl1 == 0 {
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				z.DecArrayCannotExpand(len(v), yyj1+1)
				yydb1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = 0
				} else {
					yyv1[yyj1] = (int64)(r.DecodeInt64())
				}
			}
		}
	}
	yyh1.End()
}

func (x codecSelfer19780) encSlicePtrtoint64(v []*int64, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yy2 := *yyv1
			r.EncodeInt(int64(yy2))
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decSlicePtrtoint64(v *[]*int64, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*int64{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*int64, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*int64, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(int64)
					}
					*yyv1[yyj1] = (int64)(r.DecodeInt64())
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*int64, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encSlicestringUint64T(v []stringUint64T, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decSlicestringUint64T(v *[]stringUint64T, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []stringUint64T{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]stringUint64T, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]stringUint64T, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, stringUint64T{})
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = stringUint64T{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]stringUint64T, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encMapstringPtrtostringUint64T(v map[string]*stringUint64T, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		if z.EncBasicHandle().StringToRaw {
			r.EncodeStringBytesRaw(z.BytesView(string(yyk1)))
		} else {
			r.EncodeStringEnc(codecSelferCcUTF819780, string(yyk1))
		}
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapstringPtrtostringUint64T(v *map[string]*stringUint64T, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 24)
		yyv1 = make(map[string]*stringUint64T, yyrl1)
		*v = yyv1
	}
	var yymk1 string
	var yymv1 *stringUint64T
	var yymg1, yymdn1, yyms1, yymok1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = ""
			} else {
				yymk1 = (string)(string(r.DecodeStringAsBytes()))
			}
			yyms1 = true
			if yymg1 {
				yymv1, yymok1 = yyv1[yymk1]
				if yymok1 {
					yyms1 = false
				}
			} else {
				yymv1 = nil
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				if yymv1 == nil {
					yymv1 = new(stringUint64T)
				}
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyms1 && yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encMapstringPtrtoTestStruc(v map[string]*TestStruc, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		if z.EncBasicHandle().StringToRaw {
			r.EncodeStringBytesRaw(z.BytesView(string(yyk1)))
		} else {
			r.EncodeStringEnc(codecSelferCcUTF819780, string(yyk1))
		}
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapstringPtrtoTestStruc(v *map[string]*TestStruc, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 24)
		yyv1 = make(map[string]*TestStruc, yyrl1)
		*v = yyv1
	}
	var yymk1 string
	var yymv1 *TestStruc
	var yymg1, yymdn1, yyms1, yymok1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = ""
			} else {
				yymk1 = (string)(string(r.DecodeStringAsBytes()))
			}
			yyms1 = true
			if yymg1 {
				yymv1, yymok1 = yyv1[yymk1]
				if yymok1 {
					yyms1 = false
				}
			} else {
				yymv1 = nil
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				if yymv1 == nil {
					yymv1 = new(TestStruc)
				}
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyms1 && yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encMapstringTestStruc(v map[string]TestStruc, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		if z.EncBasicHandle().StringToRaw {
			r.EncodeStringBytesRaw(z.BytesView(string(yyk1)))
		} else {
			r.EncodeStringEnc(codecSelferCcUTF819780, string(yyk1))
		}
		z.EncWriteMapElemValue()
		yy3 := &yyv1
		yy3.CodecEncodeSelf(e)
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapstringTestStruc(v *map[string]TestStruc, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 1224)
		yyv1 = make(map[string]TestStruc, yyrl1)
		*v = yyv1
	}
	var yymk1 string
	var yymv1 TestStruc
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = ""
			} else {
				yymk1 = (string)(string(r.DecodeStringAsBytes()))
			}
			if yymg1 {
				yymv1 = yyv1[yymk1]
			} else {
				yymv1 = TestStruc{}
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = TestStruc{}
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encSlicePtrtoTestStruc(v []*TestStruc, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decSlicePtrtoTestStruc(v *[]*TestStruc, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*TestStruc{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*TestStruc, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*TestStruc, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(TestStruc)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*TestStruc, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encAarray(v *Aarray, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if z.EncBasicHandle().StringToRaw {
			r.EncodeStringBytesRaw(z.BytesView(string(yyv1)))
		} else {
			r.EncodeStringEnc(codecSelferCcUTF819780, string(yyv1))
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decAarray(v *Aarray, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := v
	yyh1, yyl1 := z.DecSliceHelperStart()
	if yyl1 == 0 {
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				z.DecArrayCannotExpand(len(v), yyj1+1)
				yydb1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = ""
				} else {
					yyv1[yyj1] = (string)(string(r.DecodeStringAsBytes()))
				}
			}
		}
	}
	yyh1.End()
}

func (x codecSelfer19780) encwrapBytes(v wrapBytes, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	r.EncodeStringBytesRaw([]byte(v))
}

func (x codecSelfer19780) decwrapBytes(v *wrapBytes, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r
	*v = r.DecodeBytes(*((*[]byte)(v)), false)
}

func (x codecSelfer19780) encChanstring(v chan string, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	if v == nil {
		r.EncodeNil()
	} else {
		var sch1 []string

	Lsch1:
		switch timeout1 := z.EncBasicHandle().ChanRecvTimeout; {
		case timeout1 == 0: // only consume available
			for {
				select {
				case b1 := <-v:
					sch1 = append(sch1, b1)
				default:
					break Lsch1
				}
			}
		case timeout1 > 0: // consume until timeout
			tt1 := time.NewTimer(timeout1)
			for {
				select {
				case b1 := <-v:
					sch1 = append(sch1, b1)
				case <-tt1.C:
					// close(tt.C)
					break Lsch1
				}
			}
		default: // consume until close
			for b1 := range v {
				sch1 = append(sch1, b1)
			}
		}
		z.EncWriteArrayStart(len(sch1))
		for _, yyv1 := range sch1 {
			z.EncWriteArrayElem()
			if z.EncBasicHandle().StringToRaw {
				r.EncodeStringBytesRaw(z.BytesView(string(yyv1)))
			} else {
				r.EncodeStringEnc(codecSelferCcUTF819780, string(yyv1))
			}
		}
		z.EncWriteArrayEnd()
	}
}

func (x codecSelfer19780) decChanstring(v *chan string, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = make(chan string, 0)
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 64
				}
				yyv1 = make(chan string, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yyvcx1 string
			if r.TryDecodeAsNil() {
				yyvcx1 = ""
			} else {
				yyvcx1 = (string)(string(r.DecodeStringAsBytes()))
			}
			yyv1 <- yyvcx1
			// println(">>>> sending ", yyvcx1, " into ", yyv1) // TODO: remove this
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encMapboolc3RydWN0IHt9(v map[bool]struct{}, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		r.EncodeBool(bool(yyk1))
		z.EncWriteMapElemValue()
		yy3 := &yyv1
		z.EncFallback(yy3)
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapboolc3RydWN0IHt9(v *map[bool]struct{}, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 1)
		yyv1 = make(map[bool]struct{}, yyrl1)
		*v = yyv1
	}
	var yymk1 bool
	var yymv1 struct{}
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = false
			} else {
				yymk1 = (bool)(r.DecodeBool())
			}
			if yymg1 {
				yymv1 = yyv1[yymk1]
			} else {
				yymv1 = struct{}{}
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				z.DecFallback(&yymv1, false)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = struct{}{}
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encMapintwrapUint64Slice(v map[int]wrapUint64Slice, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		r.EncodeInt(int64(yyk1))
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapintwrapUint64Slice(v *map[int]wrapUint64Slice, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 32)
		yyv1 = make(map[int]wrapUint64Slice, yyrl1)
		*v = yyv1
	}
	var yymk1 int
	var yymv1 wrapUint64Slice
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = 0
			} else {
				yymk1 = (int)(z.C.IntV(r.DecodeInt64(), codecSelferBitsize19780))
			}
			if yymg1 {
				yymv1 = yyv1[yymk1]
			} else {
				yymv1 = nil
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encMapfloat64wrapStringSlice(v map[float64]wrapStringSlice, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		r.EncodeFloat64(float64(yyk1))
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapfloat64wrapStringSlice(v *map[float64]wrapStringSlice, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 32)
		yyv1 = make(map[float64]wrapStringSlice, yyrl1)
		*v = yyv1
	}
	var yymk1 float64
	var yymv1 wrapStringSlice
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = 0
			} else {
				yymk1 = (float64)(r.DecodeFloat64())
			}
			if yymg1 {
				yymv1 = yyv1[yymk1]
			} else {
				yymv1 = nil
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encMapfloat32wrapStringSlice(v map[float32]wrapStringSlice, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		r.EncodeFloat32(float32(yyk1))
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapfloat32wrapStringSlice(v *map[float32]wrapStringSlice, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 28)
		yyv1 = make(map[float32]wrapStringSlice, yyrl1)
		*v = yyv1
	}
	var yymk1 float32
	var yymv1 wrapStringSlice
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = 0
			} else {
				yymk1 = (float32)(z.DecDecodeFloat32())
			}
			if yymg1 {
				yymv1 = yyv1[yymk1]
			} else {
				yymv1 = nil
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encMapuint64wrapStringSlice(v map[uint64]wrapStringSlice, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		r.EncodeUint(uint64(yyk1))
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapuint64wrapStringSlice(v *map[uint64]wrapStringSlice, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 32)
		yyv1 = make(map[uint64]wrapStringSlice, yyrl1)
		*v = yyv1
	}
	var yymk1 uint64
	var yymv1 wrapStringSlice
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = 0
			} else {
				yymk1 = (uint64)(r.DecodeUint64())
			}
			if yymg1 {
				yymv1 = yyv1[yymk1]
			} else {
				yymv1 = nil
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encMapstringUint64TwrapStringSlice(v map[stringUint64T]wrapStringSlice, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		yy2 := &yyk1
		yy2.CodecEncodeSelf(e)
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapstringUint64TwrapStringSlice(v *map[stringUint64T]wrapStringSlice, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 48)
		yyv1 = make(map[stringUint64T]wrapStringSlice, yyrl1)
		*v = yyv1
	}
	var yymk1 stringUint64T
	var yymv1 wrapStringSlice
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = stringUint64T{}
			} else {
				yymk1.CodecDecodeSelf(d)
			}
			if yymg1 {
				yymv1 = yyv1[yymk1]
			} else {
				yymv1 = nil
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encSlicewrapBytes(v []wrapBytes, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decSlicewrapBytes(v *[]wrapBytes, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []wrapBytes{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]wrapBytes, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]wrapBytes, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]wrapBytes, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encSlicewrapUint8(v []wrapUint8, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		yyv1.CodecEncodeSelf(e)
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decSlicewrapUint8(v *[]wrapUint8, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []wrapUint8{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 1)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]wrapUint8, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 1)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]wrapUint8, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, 0)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = 0
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]wrapUint8, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encArray4stringUint64T(v *[4]stringUint64T, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		yy2 := &yyv1
		yy2.CodecEncodeSelf(e)
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decArray4stringUint64T(v *[4]stringUint64T, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := v
	yyh1, yyl1 := z.DecSliceHelperStart()
	if yyl1 == 0 {
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				z.DecArrayCannotExpand(len(v), yyj1+1)
				yydb1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = stringUint64T{}
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
	}
	yyh1.End()
}

func (x codecSelfer19780) encArray4uint64(v *[4]uint64, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		r.EncodeUint(uint64(yyv1))
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decArray4uint64(v *[4]uint64, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := v
	yyh1, yyl1 := z.DecSliceHelperStart()
	if yyl1 == 0 {
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				z.DecArrayCannotExpand(len(v), yyj1+1)
				yydb1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = 0
				} else {
					yyv1[yyj1] = (uint64)(r.DecodeUint64())
				}
			}
		}
	}
	yyh1.End()
}

func (x codecSelfer19780) encSlicePtrtoArray4uint64(v []*[4]uint64, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			h.encArray4uint64((*[4]uint64)(yyv1), e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decSlicePtrtoArray4uint64(v *[]*[4]uint64, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*[4]uint64{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*[4]uint64, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*[4]uint64, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new([4]uint64)
					}
					h.decArray4uint64((*[4]uint64)(yyv1[yyj1]), d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*[4]uint64, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer19780) encMapstringUint64TPtrtostringUint64T(v map[stringUint64T]*stringUint64T, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		yy2 := &yyk1
		yy2.CodecEncodeSelf(e)
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapstringUint64TPtrtostringUint64T(v *map[stringUint64T]*stringUint64T, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 32)
		yyv1 = make(map[stringUint64T]*stringUint64T, yyrl1)
		*v = yyv1
	}
	var yymk1 stringUint64T
	var yymv1 *stringUint64T
	var yymg1, yymdn1, yyms1, yymok1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = stringUint64T{}
			} else {
				yymk1.CodecDecodeSelf(d)
			}
			yyms1 = true
			if yymg1 {
				yymv1, yymok1 = yyv1[yymk1]
				if yymok1 {
					yyms1 = false
				}
			} else {
				yymv1 = nil
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				if yymv1 == nil {
					yymv1 = new(stringUint64T)
				}
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyms1 && yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encMapstringPtrtoTestStrucFlex(v map[string]*TestStrucFlex, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		if z.EncBasicHandle().StringToRaw {
			r.EncodeStringBytesRaw(z.BytesView(string(yyk1)))
		} else {
			r.EncodeStringEnc(codecSelferCcUTF819780, string(yyk1))
		}
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapstringPtrtoTestStrucFlex(v *map[string]*TestStrucFlex, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 24)
		yyv1 = make(map[string]*TestStrucFlex, yyrl1)
		*v = yyv1
	}
	var yymk1 string
	var yymv1 *TestStrucFlex
	var yymg1, yymdn1, yyms1, yymok1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = ""
			} else {
				yymk1 = (string)(string(r.DecodeStringAsBytes()))
			}
			yyms1 = true
			if yymg1 {
				yymv1, yymok1 = yyv1[yymk1]
				if yymok1 {
					yyms1 = false
				}
			} else {
				yymv1 = nil
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				if yymv1 == nil {
					yymv1 = new(TestStrucFlex)
				}
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = nil
				}
			} else if yyms1 && yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encMapstringTestStrucFlex(v map[string]TestStrucFlex, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		if z.EncBasicHandle().StringToRaw {
			r.EncodeStringBytesRaw(z.BytesView(string(yyk1)))
		} else {
			r.EncodeStringEnc(codecSelferCcUTF819780, string(yyk1))
		}
		z.EncWriteMapElemValue()
		yy3 := &yyv1
		yy3.CodecEncodeSelf(e)
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer19780) decMapstringTestStrucFlex(v *map[string]TestStrucFlex, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	yybh1 := z.DecBasicHandle()
	if yyv1 == nil {
		yyrl1 := z.DecInferLen(yyl1, yybh1.MaxInitLen, 1536)
		yyv1 = make(map[string]TestStrucFlex, yyrl1)
		*v = yyv1
	}
	var yymk1 string
	var yymv1 TestStrucFlex
	var yymg1, yymdn1 bool
	if yybh1.MapValueReset {
		yymg1 = true
	}
	if yyl1 != 0 {
		yyhl1 := yyl1 > 0
		for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ {
			z.DecReadMapElemKey()
			if r.TryDecodeAsNil() {
				yymk1 = ""
			} else {
				yymk1 = (string)(string(r.DecodeStringAsBytes()))
			}
			if yymg1 {
				yymv1 = yyv1[yymk1]
			} else {
				yymv1 = TestStrucFlex{}
			}
			z.DecReadMapElemValue()
			yymdn1 = false
			if r.TryDecodeAsNil() {
				yymdn1 = true
			} else {
				yymv1.CodecDecodeSelf(d)
			}
			if yymdn1 {
				if yybh1.DeleteOnNilMapValue {
					delete(yyv1, yymk1)
				} else {
					yyv1[yymk1] = TestStrucFlex{}
				}
			} else if yyv1 != nil {
				yyv1[yymk1] = yymv1
			}
		}
	} // else len==0: TODO: Should we clear map entries?
	z.DecReadMapEnd()
}

func (x codecSelfer19780) encSlicePtrtoTestStrucFlex(v []*TestStrucFlex, e *Encoder) {
	var h codecSelfer19780
	z, r := GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer19780) decSlicePtrtoTestStrucFlex(v *[]*TestStrucFlex, d *Decoder) {
	var h codecSelfer19780
	z, r := GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*TestStrucFlex{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*TestStrucFlex, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || r.CheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*TestStrucFlex, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryDecodeAsNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(TestStrucFlex)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*TestStrucFlex, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}
